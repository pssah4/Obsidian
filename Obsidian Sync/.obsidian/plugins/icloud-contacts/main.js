/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/foldline/foldline.js
var require_foldline = __commonJS({
  "node_modules/foldline/foldline.js"(exports, module2) {
    var CRLF = "\r\n";
    var SP = " ";
    var MAX_LINE_LENGTH = 998;
    var DEFAULT_LINE_LENGTH = 78;
    var MIN_LINE_LENGTH = 2;
    function foldLine(input, maxLength, hardWrap) {
      if (maxLength != null && maxLength < MIN_LINE_LENGTH) {
        throw new Error("Maximum length must not be less than " + MIN_LINE_LENGTH);
      }
      if (maxLength != null && maxLength > MAX_LINE_LENGTH) {
        throw new Error("Maximum length must not exceed " + MAX_LINE_LENGTH);
      }
      maxLength = maxLength || DEFAULT_LINE_LENGTH;
      input = input.replace(/[\r\n]+/g, "");
      if (input.length <= maxLength) {
        return input;
      }
      var output = "";
      var index = 0;
      var nextIndex = 0;
      var length = input.length;
      var line = 0;
      var trim = 0;
      while (index < length) {
        if (!hardWrap && ~(nextIndex = input.lastIndexOf(SP, index + maxLength))) {
          if (nextIndex > index) {
            output += input.slice(index, nextIndex) + CRLF + SP;
            index = nextIndex;
          } else {
            output += input.slice(index, index + maxLength - trim) + CRLF + SP;
            index = index + maxLength - trim;
            hardWrap = true;
          }
        } else {
          output += input.slice(index, index + maxLength - trim) + CRLF + SP;
          index = index + maxLength - trim;
        }
        if (length - index < maxLength) {
          output += input.slice(index);
          break;
        }
        if (line === 0) {
          trim = 1;
        }
        line++;
      }
      return output;
    }
    foldLine.unfold = function unfold(input) {
      return input.replace(/\r\n\s/gm, "");
    };
    module2.exports = foldLine;
  }
});

// node_modules/camelcase/index.js
var require_camelcase = __commonJS({
  "node_modules/camelcase/index.js"(exports, module2) {
    "use strict";
    var preserveCamelCase = (string) => {
      let isLastCharLower = false;
      let isLastCharUpper = false;
      let isLastLastCharUpper = false;
      for (let i = 0; i < string.length; i++) {
        const character = string[i];
        if (isLastCharLower && /[a-zA-Z]/.test(character) && character.toUpperCase() === character) {
          string = string.slice(0, i) + "-" + string.slice(i);
          isLastCharLower = false;
          isLastLastCharUpper = isLastCharUpper;
          isLastCharUpper = true;
          i++;
        } else if (isLastCharUpper && isLastLastCharUpper && /[a-zA-Z]/.test(character) && character.toLowerCase() === character) {
          string = string.slice(0, i - 1) + "-" + string.slice(i - 1);
          isLastLastCharUpper = isLastCharUpper;
          isLastCharUpper = false;
          isLastCharLower = true;
        } else {
          isLastCharLower = character.toLowerCase() === character && character.toUpperCase() !== character;
          isLastLastCharUpper = isLastCharUpper;
          isLastCharUpper = character.toUpperCase() === character && character.toLowerCase() !== character;
        }
      }
      return string;
    };
    var camelCase2 = (input, options) => {
      if (!(typeof input === "string" || Array.isArray(input))) {
        throw new TypeError("Expected the input to be `string | string[]`");
      }
      options = Object.assign({
        pascalCase: false
      }, options);
      const postProcess = (x) => options.pascalCase ? x.charAt(0).toUpperCase() + x.slice(1) : x;
      if (Array.isArray(input)) {
        input = input.map((x) => x.trim()).filter((x) => x.length).join("-");
      } else {
        input = input.trim();
      }
      if (input.length === 0) {
        return "";
      }
      if (input.length === 1) {
        return options.pascalCase ? input.toUpperCase() : input.toLowerCase();
      }
      const hasUpperCase = input !== input.toLowerCase();
      if (hasUpperCase) {
        input = preserveCamelCase(input);
      }
      input = input.replace(/^[_.\- ]+/, "").toLowerCase().replace(/[_.\- ]+(\w|$)/g, (_, p1) => p1.toUpperCase()).replace(/\d+(\w|$)/g, (m) => m.toUpperCase());
      return postProcess(input);
    };
    module2.exports = camelCase2;
    module2.exports.default = camelCase2;
  }
});

// node_modules/vcf/lib/property.js
var require_property = __commonJS({
  "node_modules/vcf/lib/property.js"(exports, module2) {
    function Property(field, value, params) {
      if (!(this instanceof Property))
        return new Property(value);
      if (params != null)
        Object.assign(this, params);
      this._field = field;
      this._data = value;
      Object.defineProperty(this, "_field", { enumerable: false });
      Object.defineProperty(this, "_data", { enumerable: false });
    }
    Property.fromJSON = function(data) {
      var field = data[0];
      var params = data[1];
      if (!/text/i.test(data[2]))
        params.value = data[2];
      var value = Array.isArray(data[3]) ? data[3].join(";") : data[3];
      return new Property(field, value, params);
    };
    function capitalDashCase(value) {
      return value.replace(/([A-Z])/g, "-$1").toUpperCase();
    }
    Property.prototype = {
      constructor: Property,
      /**
       * Check whether the property is of a given type
       * @param  {String}  type
       * @return {Boolean}
       */
      is: function(type) {
        type = (type + "").toLowerCase();
        return Array.isArray(this.type) ? this.type.indexOf(type) >= 0 : this.type === type;
      },
      /**
       * Check whether the property is empty
       * @return {Boolean}
       */
      isEmpty: function() {
        return this._data == null && Object.keys(this).length === 0;
      },
      /**
       * Clone the property
       * @return {Property}
       */
      clone: function() {
        return new Property(this._field, this._data, this);
      },
      /**
       * Format the property as vcf with given version
       * @param  {String} version
       * @return {String}
       */
      toString: function(version) {
        var propName = (this.group ? this.group + "." : "") + capitalDashCase(this._field);
        var keys = Object.keys(this);
        var params = [];
        for (var i = 0; i < keys.length; i++) {
          if (keys[i] === "group") continue;
          switch (propName) {
            case "TEL":
            case "ADR":
            case "EMAIL":
              if (version === "2.1") {
                if (Array.isArray(this[keys[i]]))
                  params.push(this[keys[i]].join(";"));
                else
                  params.push(this[keys[i]]);
              } else
                params.push(capitalDashCase(keys[i]) + "=" + this[keys[i]]);
              break;
            default:
              params.push(capitalDashCase(keys[i]) + "=" + this[keys[i]]);
          }
        }
        if (version === "2.1" || version === "3.0")
          return propName + (params.length ? ";" + params.join(";").toUpperCase() : params.toString().toUpperCase()) + ":" + (Array.isArray(this._data) ? this._data.join(";") : this._data);
        else
          return propName + (params.length ? ";" + params.join(";") : params) + ":" + (Array.isArray(this._data) ? this._data.join(";") : this._data);
      },
      /**
       * Get the property's value
       * @return {String}
       */
      valueOf: function() {
        return this._data;
      },
      /**
       * Format the property as jCard data
       * @return {Array}
       */
      toJSON: function() {
        var params = Object.assign({}, this);
        if (params.value === "text") {
          params.value = void 0;
          delete params.value;
        }
        var data = [this._field, params, this.value || "text"];
        switch (this._field) {
          default:
            data.push(this._data);
            break;
          case "adr":
          case "n":
            data.push(this._data.split(";"));
        }
        return data;
      }
    };
    module2.exports = Property;
  }
});

// node_modules/vcf/lib/parse-lines.js
var require_parse_lines = __commonJS({
  "node_modules/vcf/lib/parse-lines.js"(exports, module2) {
    var camelCase2 = require_camelcase();
    var Property = require_property();
    function set(object, key, value) {
      if (Array.isArray(object[key])) {
        object[key].push(value);
      } else if (object[key] != null) {
        object[key] = [object[key], value];
      } else {
        object[key] = value;
      }
    }
    function createParams(params, param) {
      var parts = param.split("=");
      var k = camelCase2(parts[0]);
      var value = parts[1];
      if (value == null || value === "") {
        value = parts[0];
        k = "type";
      }
      if (k === "type") {
        if (value[0] === '"' && value[value.length - 1] === '"' && value.indexOf(",") !== -1)
          value = value.slice(1, -1);
        value.toLowerCase().split(",").forEach(function(value2) {
          set(params, k, value2);
        });
        return params;
      }
      set(params, k, value);
      return params;
    }
    function parseLines(lines) {
      var data = {};
      var line = null;
      var pattern = /^([^;:]+)((?:;(?:[^;:]+))*)(?:\:([\s\S]+))?$/i;
      var len = lines.length - 1;
      for (var i = 1; i < len; i++) {
        line = lines[i];
        var match = pattern.exec(line);
        if (!match) continue;
        var name = match[1].split(".");
        var property = name.pop();
        var group = name.pop();
        var value = match[3];
        var params = match[2] ? match[2].replace(/^;|;$/g, "").split(";") : [];
        var propParams = params.reduce(createParams, group ? { group } : {});
        var propName = camelCase2(property);
        var propVal = new Property(propName, value, propParams);
        set(data, propName, propVal);
      }
      return data;
    }
    module2.exports = parseLines;
  }
});

// node_modules/vcf/lib/vcard.js
var require_vcard = __commonJS({
  "node_modules/vcf/lib/vcard.js"(exports, module2) {
    function vCard() {
      if (!(this instanceof vCard))
        return new vCard();
      this.version = vCard.versions[vCard.versions.length - 1];
      this.data = {};
    }
    vCard.mimeType = "text/vcard";
    vCard.extension = ".vcf";
    vCard.versions = ["2.1", "3.0", "4.0"];
    vCard.EOL = "\r\n";
    vCard.foldLine = require_foldline();
    vCard.normalize = function(input) {
      return (input + "").replace(/^[\s\r\n]+|[\s\r\n]+$/g, "").replace(/(\r\n)[\x09\x20]?(\r\n)|$/g, "$1").replace(/\r\n[\x20\x09]/g, "");
    };
    vCard.isSupported = function(version) {
      return /^\d\.\d$/.test(version) && vCard.versions.indexOf(version) !== -1;
    };
    vCard.parse = function(value) {
      var objects = (value + "").split(/(?=BEGIN\:VCARD)/gi);
      var cards = [];
      for (var i = 0; i < objects.length; i++) {
        cards.push(new vCard().parse(objects[i]));
      }
      return cards;
    };
    vCard.parseLines = require_parse_lines();
    vCard.fromJSON = function(jcard) {
      jcard = typeof jcard === "string" ? JSON.parse(jcard) : jcard;
      if (jcard == null || !Array.isArray(jcard))
        return new vCard();
      if (!/vcard/i.test(jcard[0]))
        throw new Error("Object not in jCard format");
      var card = new vCard();
      jcard[1].forEach(function(prop) {
        card.addProperty(vCard.Property.fromJSON(prop));
      });
      return card;
    };
    vCard.format = function(card, version) {
      version = version || card.version || vCard.versions[vCard.versions.length - 1];
      if (!vCard.isSupported(version))
        throw new Error('Unsupported vCard version "' + version + '"');
      var vcf = [];
      vcf.push("BEGIN:VCARD");
      vcf.push("VERSION:" + version);
      var props = Object.keys(card.data);
      var prop = "";
      for (var i = 0; i < props.length; i++) {
        if (props[i] === "version") continue;
        prop = card.data[props[i]];
        if (Array.isArray(prop)) {
          for (var k = 0; k < prop.length; k++) {
            if (prop[k].isEmpty()) continue;
            vcf.push(vCard.foldLine(prop[k].toString(version), 75));
          }
        } else if (!prop.isEmpty()) {
          vcf.push(vCard.foldLine(prop.toString(version), 75));
        }
      }
      vcf.push("END:VCARD");
      return vcf.join(vCard.EOL);
    };
    vCard.Property = require_property();
    vCard.prototype = {
      constructor: vCard,
      /**
       * Get a vCard property
       * @param  {String} key
       * @return {Object|Array}
       */
      get: function(key) {
        if (this.data[key] == null) {
          return this.data[key];
        }
        if (Array.isArray(this.data[key])) {
          return this.data[key].map(function(prop) {
            return prop.clone();
          });
        } else {
          return this.data[key].clone();
        }
      },
      /**
       * Set a vCard property
       * @param {String} key
       * @param {String} value
       * @param {Object} params
       */
      set: function(key, value, params) {
        return this.setProperty(new vCard.Property(key, value, params));
      },
      /**
       * Add a vCard property
       * @param {String} key
       * @param {String} value
       * @param {Object} params
       */
      add: function(key, value, params) {
        var prop = new vCard.Property(key, value, params);
        this.addProperty(prop);
        return this;
      },
      /**
       * Set a vCard property from an already
       * constructed vCard.Property
       * @param {vCard.Property} prop
       */
      setProperty: function(prop) {
        this.data[prop._field] = prop;
        return this;
      },
      /**
       * Add a vCard property from an already
       * constructed vCard.Property
       * @param {vCard.Property} prop
       */
      addProperty: function(prop) {
        var key = prop._field;
        if (Array.isArray(this.data[key])) {
          this.data[key].push(prop);
        } else if (this.data[key] != null) {
          this.data[key] = [this.data[key], prop];
        } else {
          this.data[key] = prop;
        }
        return this;
      },
      /**
       * Parse a vcf formatted vCard
       * @param  {String} value
       * @return {vCard}
       */
      parse: function(value) {
        var lines = vCard.normalize(value).split(/\r\n/g);
        var begin = lines[0];
        var version = lines[1];
        var end = lines[lines.length - 1];
        const regexp_version = /VERSION:\d\.\d/i;
        if (!/BEGIN:VCARD/i.test(begin))
          throw new SyntaxError('Invalid vCard: Expected "BEGIN:VCARD" but found "' + begin + '"');
        if (!/END:VCARD/i.test(end))
          throw new SyntaxError('Invalid vCard: Expected "END:VCARD" but found "' + end + '"');
        if (!regexp_version.test(version)) {
          if (!(version = lines.find((line) => regexp_version.test(line))))
            throw new SyntaxError('Invalid vCard: Expected "VERSION:\\d.\\d" but none found');
        }
        this.version = version.substring(8, 11);
        if (!vCard.isSupported(this.version))
          throw new Error('Unsupported version "' + this.version + '"');
        this.data = vCard.parseLines(lines);
        return this;
      },
      /**
       * Format the vCard as vcf with given version
       * @param  {String} version
       * @param  {String} charset
       * @return {String}
       */
      toString: function(version, charset) {
        version = version || this.version;
        return vCard.format(this, version);
      },
      /**
       * Format the card as jCard
       * @param {String} version='4.0'
       * @return {Array} jCard
       */
      toJCard: function(version) {
        version = version || "4.0";
        var keys = Object.keys(this.data);
        var data = [["version", {}, "text", version]];
        var prop = null;
        for (var i = 0; i < keys.length; i++) {
          if (keys[i] === "version") continue;
          prop = this.data[keys[i]];
          if (Array.isArray(prop)) {
            for (var k = 0; k < prop.length; k++) {
              data.push(prop[k].toJSON());
            }
          } else {
            data.push(prop.toJSON());
          }
        }
        return ["vcard", data];
      },
      /**
       * Format the card as jCard
       * @return {Array} jCard
       */
      toJSON: function() {
        return this.toJCard(this.version);
      }
    };
    module2.exports = vCard;
  }
});

// node_modules/sax/lib/sax.js
var require_sax = __commonJS({
  "node_modules/sax/lib/sax.js"(exports) {
    (function(sax) {
      sax.parser = function(strict, opt) {
        return new SAXParser(strict, opt);
      };
      sax.SAXParser = SAXParser;
      sax.SAXStream = SAXStream;
      sax.createStream = createStream;
      sax.MAX_BUFFER_LENGTH = 64 * 1024;
      var buffers = [
        "comment",
        "sgmlDecl",
        "textNode",
        "tagName",
        "doctype",
        "procInstName",
        "procInstBody",
        "entity",
        "attribName",
        "attribValue",
        "cdata",
        "script"
      ];
      sax.EVENTS = [
        "text",
        "processinginstruction",
        "sgmldeclaration",
        "doctype",
        "comment",
        "opentagstart",
        "attribute",
        "opentag",
        "closetag",
        "opencdata",
        "cdata",
        "closecdata",
        "error",
        "end",
        "ready",
        "script",
        "opennamespace",
        "closenamespace"
      ];
      function SAXParser(strict, opt) {
        if (!(this instanceof SAXParser)) {
          return new SAXParser(strict, opt);
        }
        var parser = this;
        clearBuffers(parser);
        parser.q = parser.c = "";
        parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;
        parser.opt = opt || {};
        parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
        parser.looseCase = parser.opt.lowercase ? "toLowerCase" : "toUpperCase";
        parser.tags = [];
        parser.closed = parser.closedRoot = parser.sawRoot = false;
        parser.tag = parser.error = null;
        parser.strict = !!strict;
        parser.noscript = !!(strict || parser.opt.noscript);
        parser.state = S.BEGIN;
        parser.strictEntities = parser.opt.strictEntities;
        parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES);
        parser.attribList = [];
        if (parser.opt.xmlns) {
          parser.ns = Object.create(rootNS);
        }
        if (parser.opt.unquotedAttributeValues === void 0) {
          parser.opt.unquotedAttributeValues = !strict;
        }
        parser.trackPosition = parser.opt.position !== false;
        if (parser.trackPosition) {
          parser.position = parser.line = parser.column = 0;
        }
        emit(parser, "onready");
      }
      if (!Object.create) {
        Object.create = function(o) {
          function F() {
          }
          F.prototype = o;
          var newf = new F();
          return newf;
        };
      }
      if (!Object.keys) {
        Object.keys = function(o) {
          var a = [];
          for (var i in o) if (o.hasOwnProperty(i)) a.push(i);
          return a;
        };
      }
      function checkBufferLength(parser) {
        var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);
        var maxActual = 0;
        for (var i = 0, l = buffers.length; i < l; i++) {
          var len = parser[buffers[i]].length;
          if (len > maxAllowed) {
            switch (buffers[i]) {
              case "textNode":
                closeText(parser);
                break;
              case "cdata":
                emitNode(parser, "oncdata", parser.cdata);
                parser.cdata = "";
                break;
              case "script":
                emitNode(parser, "onscript", parser.script);
                parser.script = "";
                break;
              default:
                error(parser, "Max buffer length exceeded: " + buffers[i]);
            }
          }
          maxActual = Math.max(maxActual, len);
        }
        var m = sax.MAX_BUFFER_LENGTH - maxActual;
        parser.bufferCheckPosition = m + parser.position;
      }
      function clearBuffers(parser) {
        for (var i = 0, l = buffers.length; i < l; i++) {
          parser[buffers[i]] = "";
        }
      }
      function flushBuffers(parser) {
        closeText(parser);
        if (parser.cdata !== "") {
          emitNode(parser, "oncdata", parser.cdata);
          parser.cdata = "";
        }
        if (parser.script !== "") {
          emitNode(parser, "onscript", parser.script);
          parser.script = "";
        }
      }
      SAXParser.prototype = {
        end: function() {
          end(this);
        },
        write,
        resume: function() {
          this.error = null;
          return this;
        },
        close: function() {
          return this.write(null);
        },
        flush: function() {
          flushBuffers(this);
        }
      };
      var Stream;
      try {
        Stream = require("stream").Stream;
      } catch (ex) {
        Stream = function() {
        };
      }
      if (!Stream) Stream = function() {
      };
      var streamWraps = sax.EVENTS.filter(function(ev) {
        return ev !== "error" && ev !== "end";
      });
      function createStream(strict, opt) {
        return new SAXStream(strict, opt);
      }
      function SAXStream(strict, opt) {
        if (!(this instanceof SAXStream)) {
          return new SAXStream(strict, opt);
        }
        Stream.apply(this);
        this._parser = new SAXParser(strict, opt);
        this.writable = true;
        this.readable = true;
        var me = this;
        this._parser.onend = function() {
          me.emit("end");
        };
        this._parser.onerror = function(er) {
          me.emit("error", er);
          me._parser.error = null;
        };
        this._decoder = null;
        streamWraps.forEach(function(ev) {
          Object.defineProperty(me, "on" + ev, {
            get: function() {
              return me._parser["on" + ev];
            },
            set: function(h) {
              if (!h) {
                me.removeAllListeners(ev);
                me._parser["on" + ev] = h;
                return h;
              }
              me.on(ev, h);
            },
            enumerable: true,
            configurable: false
          });
        });
      }
      SAXStream.prototype = Object.create(Stream.prototype, {
        constructor: {
          value: SAXStream
        }
      });
      SAXStream.prototype.write = function(data) {
        if (typeof Buffer === "function" && typeof Buffer.isBuffer === "function" && Buffer.isBuffer(data)) {
          if (!this._decoder) {
            var SD = require("string_decoder").StringDecoder;
            this._decoder = new SD("utf8");
          }
          data = this._decoder.write(data);
        }
        this._parser.write(data.toString());
        this.emit("data", data);
        return true;
      };
      SAXStream.prototype.end = function(chunk) {
        if (chunk && chunk.length) {
          this.write(chunk);
        }
        this._parser.end();
        return true;
      };
      SAXStream.prototype.on = function(ev, handler) {
        var me = this;
        if (!me._parser["on" + ev] && streamWraps.indexOf(ev) !== -1) {
          me._parser["on" + ev] = function() {
            var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
            args.splice(0, 0, ev);
            me.emit.apply(me, args);
          };
        }
        return Stream.prototype.on.call(me, ev, handler);
      };
      var CDATA = "[CDATA[";
      var DOCTYPE = "DOCTYPE";
      var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
      var XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/";
      var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };
      var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
      var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
      var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      function isWhitespace(c) {
        return c === " " || c === "\n" || c === "\r" || c === "	";
      }
      function isQuote(c) {
        return c === '"' || c === "'";
      }
      function isAttribEnd(c) {
        return c === ">" || isWhitespace(c);
      }
      function isMatch(regex, c) {
        return regex.test(c);
      }
      function notMatch(regex, c) {
        return !isMatch(regex, c);
      }
      var S = 0;
      sax.STATE = {
        BEGIN: S++,
        // leading byte order mark or whitespace
        BEGIN_WHITESPACE: S++,
        // leading whitespace
        TEXT: S++,
        // general stuff
        TEXT_ENTITY: S++,
        // &amp and such.
        OPEN_WAKA: S++,
        // <
        SGML_DECL: S++,
        // <!BLARG
        SGML_DECL_QUOTED: S++,
        // <!BLARG foo "bar
        DOCTYPE: S++,
        // <!DOCTYPE
        DOCTYPE_QUOTED: S++,
        // <!DOCTYPE "//blah
        DOCTYPE_DTD: S++,
        // <!DOCTYPE "//blah" [ ...
        DOCTYPE_DTD_QUOTED: S++,
        // <!DOCTYPE "//blah" [ "foo
        COMMENT_STARTING: S++,
        // <!-
        COMMENT: S++,
        // <!--
        COMMENT_ENDING: S++,
        // <!-- blah -
        COMMENT_ENDED: S++,
        // <!-- blah --
        CDATA: S++,
        // <![CDATA[ something
        CDATA_ENDING: S++,
        // ]
        CDATA_ENDING_2: S++,
        // ]]
        PROC_INST: S++,
        // <?hi
        PROC_INST_BODY: S++,
        // <?hi there
        PROC_INST_ENDING: S++,
        // <?hi "there" ?
        OPEN_TAG: S++,
        // <strong
        OPEN_TAG_SLASH: S++,
        // <strong /
        ATTRIB: S++,
        // <a
        ATTRIB_NAME: S++,
        // <a foo
        ATTRIB_NAME_SAW_WHITE: S++,
        // <a foo _
        ATTRIB_VALUE: S++,
        // <a foo=
        ATTRIB_VALUE_QUOTED: S++,
        // <a foo="bar
        ATTRIB_VALUE_CLOSED: S++,
        // <a foo="bar"
        ATTRIB_VALUE_UNQUOTED: S++,
        // <a foo=bar
        ATTRIB_VALUE_ENTITY_Q: S++,
        // <foo bar="&quot;"
        ATTRIB_VALUE_ENTITY_U: S++,
        // <foo bar=&quot
        CLOSE_TAG: S++,
        // </a
        CLOSE_TAG_SAW_WHITE: S++,
        // </a   >
        SCRIPT: S++,
        // <script> ...
        SCRIPT_ENDING: S++
        // <script> ... <
      };
      sax.XML_ENTITIES = {
        "amp": "&",
        "gt": ">",
        "lt": "<",
        "quot": '"',
        "apos": "'"
      };
      sax.ENTITIES = {
        "amp": "&",
        "gt": ">",
        "lt": "<",
        "quot": '"',
        "apos": "'",
        "AElig": 198,
        "Aacute": 193,
        "Acirc": 194,
        "Agrave": 192,
        "Aring": 197,
        "Atilde": 195,
        "Auml": 196,
        "Ccedil": 199,
        "ETH": 208,
        "Eacute": 201,
        "Ecirc": 202,
        "Egrave": 200,
        "Euml": 203,
        "Iacute": 205,
        "Icirc": 206,
        "Igrave": 204,
        "Iuml": 207,
        "Ntilde": 209,
        "Oacute": 211,
        "Ocirc": 212,
        "Ograve": 210,
        "Oslash": 216,
        "Otilde": 213,
        "Ouml": 214,
        "THORN": 222,
        "Uacute": 218,
        "Ucirc": 219,
        "Ugrave": 217,
        "Uuml": 220,
        "Yacute": 221,
        "aacute": 225,
        "acirc": 226,
        "aelig": 230,
        "agrave": 224,
        "aring": 229,
        "atilde": 227,
        "auml": 228,
        "ccedil": 231,
        "eacute": 233,
        "ecirc": 234,
        "egrave": 232,
        "eth": 240,
        "euml": 235,
        "iacute": 237,
        "icirc": 238,
        "igrave": 236,
        "iuml": 239,
        "ntilde": 241,
        "oacute": 243,
        "ocirc": 244,
        "ograve": 242,
        "oslash": 248,
        "otilde": 245,
        "ouml": 246,
        "szlig": 223,
        "thorn": 254,
        "uacute": 250,
        "ucirc": 251,
        "ugrave": 249,
        "uuml": 252,
        "yacute": 253,
        "yuml": 255,
        "copy": 169,
        "reg": 174,
        "nbsp": 160,
        "iexcl": 161,
        "cent": 162,
        "pound": 163,
        "curren": 164,
        "yen": 165,
        "brvbar": 166,
        "sect": 167,
        "uml": 168,
        "ordf": 170,
        "laquo": 171,
        "not": 172,
        "shy": 173,
        "macr": 175,
        "deg": 176,
        "plusmn": 177,
        "sup1": 185,
        "sup2": 178,
        "sup3": 179,
        "acute": 180,
        "micro": 181,
        "para": 182,
        "middot": 183,
        "cedil": 184,
        "ordm": 186,
        "raquo": 187,
        "frac14": 188,
        "frac12": 189,
        "frac34": 190,
        "iquest": 191,
        "times": 215,
        "divide": 247,
        "OElig": 338,
        "oelig": 339,
        "Scaron": 352,
        "scaron": 353,
        "Yuml": 376,
        "fnof": 402,
        "circ": 710,
        "tilde": 732,
        "Alpha": 913,
        "Beta": 914,
        "Gamma": 915,
        "Delta": 916,
        "Epsilon": 917,
        "Zeta": 918,
        "Eta": 919,
        "Theta": 920,
        "Iota": 921,
        "Kappa": 922,
        "Lambda": 923,
        "Mu": 924,
        "Nu": 925,
        "Xi": 926,
        "Omicron": 927,
        "Pi": 928,
        "Rho": 929,
        "Sigma": 931,
        "Tau": 932,
        "Upsilon": 933,
        "Phi": 934,
        "Chi": 935,
        "Psi": 936,
        "Omega": 937,
        "alpha": 945,
        "beta": 946,
        "gamma": 947,
        "delta": 948,
        "epsilon": 949,
        "zeta": 950,
        "eta": 951,
        "theta": 952,
        "iota": 953,
        "kappa": 954,
        "lambda": 955,
        "mu": 956,
        "nu": 957,
        "xi": 958,
        "omicron": 959,
        "pi": 960,
        "rho": 961,
        "sigmaf": 962,
        "sigma": 963,
        "tau": 964,
        "upsilon": 965,
        "phi": 966,
        "chi": 967,
        "psi": 968,
        "omega": 969,
        "thetasym": 977,
        "upsih": 978,
        "piv": 982,
        "ensp": 8194,
        "emsp": 8195,
        "thinsp": 8201,
        "zwnj": 8204,
        "zwj": 8205,
        "lrm": 8206,
        "rlm": 8207,
        "ndash": 8211,
        "mdash": 8212,
        "lsquo": 8216,
        "rsquo": 8217,
        "sbquo": 8218,
        "ldquo": 8220,
        "rdquo": 8221,
        "bdquo": 8222,
        "dagger": 8224,
        "Dagger": 8225,
        "bull": 8226,
        "hellip": 8230,
        "permil": 8240,
        "prime": 8242,
        "Prime": 8243,
        "lsaquo": 8249,
        "rsaquo": 8250,
        "oline": 8254,
        "frasl": 8260,
        "euro": 8364,
        "image": 8465,
        "weierp": 8472,
        "real": 8476,
        "trade": 8482,
        "alefsym": 8501,
        "larr": 8592,
        "uarr": 8593,
        "rarr": 8594,
        "darr": 8595,
        "harr": 8596,
        "crarr": 8629,
        "lArr": 8656,
        "uArr": 8657,
        "rArr": 8658,
        "dArr": 8659,
        "hArr": 8660,
        "forall": 8704,
        "part": 8706,
        "exist": 8707,
        "empty": 8709,
        "nabla": 8711,
        "isin": 8712,
        "notin": 8713,
        "ni": 8715,
        "prod": 8719,
        "sum": 8721,
        "minus": 8722,
        "lowast": 8727,
        "radic": 8730,
        "prop": 8733,
        "infin": 8734,
        "ang": 8736,
        "and": 8743,
        "or": 8744,
        "cap": 8745,
        "cup": 8746,
        "int": 8747,
        "there4": 8756,
        "sim": 8764,
        "cong": 8773,
        "asymp": 8776,
        "ne": 8800,
        "equiv": 8801,
        "le": 8804,
        "ge": 8805,
        "sub": 8834,
        "sup": 8835,
        "nsub": 8836,
        "sube": 8838,
        "supe": 8839,
        "oplus": 8853,
        "otimes": 8855,
        "perp": 8869,
        "sdot": 8901,
        "lceil": 8968,
        "rceil": 8969,
        "lfloor": 8970,
        "rfloor": 8971,
        "lang": 9001,
        "rang": 9002,
        "loz": 9674,
        "spades": 9824,
        "clubs": 9827,
        "hearts": 9829,
        "diams": 9830
      };
      Object.keys(sax.ENTITIES).forEach(function(key) {
        var e = sax.ENTITIES[key];
        var s2 = typeof e === "number" ? String.fromCharCode(e) : e;
        sax.ENTITIES[key] = s2;
      });
      for (var s in sax.STATE) {
        sax.STATE[sax.STATE[s]] = s;
      }
      S = sax.STATE;
      function emit(parser, event, data) {
        parser[event] && parser[event](data);
      }
      function emitNode(parser, nodeType, data) {
        if (parser.textNode) closeText(parser);
        emit(parser, nodeType, data);
      }
      function closeText(parser) {
        parser.textNode = textopts(parser.opt, parser.textNode);
        if (parser.textNode) emit(parser, "ontext", parser.textNode);
        parser.textNode = "";
      }
      function textopts(opt, text) {
        if (opt.trim) text = text.trim();
        if (opt.normalize) text = text.replace(/\s+/g, " ");
        return text;
      }
      function error(parser, er) {
        closeText(parser);
        if (parser.trackPosition) {
          er += "\nLine: " + parser.line + "\nColumn: " + parser.column + "\nChar: " + parser.c;
        }
        er = new Error(er);
        parser.error = er;
        emit(parser, "onerror", er);
        return parser;
      }
      function end(parser) {
        if (parser.sawRoot && !parser.closedRoot) strictFail(parser, "Unclosed root tag");
        if (parser.state !== S.BEGIN && parser.state !== S.BEGIN_WHITESPACE && parser.state !== S.TEXT) {
          error(parser, "Unexpected end");
        }
        closeText(parser);
        parser.c = "";
        parser.closed = true;
        emit(parser, "onend");
        SAXParser.call(parser, parser.strict, parser.opt);
        return parser;
      }
      function strictFail(parser, message) {
        if (typeof parser !== "object" || !(parser instanceof SAXParser)) {
          throw new Error("bad call to strictFail");
        }
        if (parser.strict) {
          error(parser, message);
        }
      }
      function newTag(parser) {
        if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]();
        var parent = parser.tags[parser.tags.length - 1] || parser;
        var tag = parser.tag = { name: parser.tagName, attributes: {} };
        if (parser.opt.xmlns) {
          tag.ns = parent.ns;
        }
        parser.attribList.length = 0;
        emitNode(parser, "onopentagstart", tag);
      }
      function qname(name, attribute) {
        var i = name.indexOf(":");
        var qualName = i < 0 ? ["", name] : name.split(":");
        var prefix = qualName[0];
        var local = qualName[1];
        if (attribute && name === "xmlns") {
          prefix = "xmlns";
          local = "";
        }
        return { prefix, local };
      }
      function attrib(parser) {
        if (!parser.strict) {
          parser.attribName = parser.attribName[parser.looseCase]();
        }
        if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {
          parser.attribName = parser.attribValue = "";
          return;
        }
        if (parser.opt.xmlns) {
          var qn = qname(parser.attribName, true);
          var prefix = qn.prefix;
          var local = qn.local;
          if (prefix === "xmlns") {
            if (local === "xml" && parser.attribValue !== XML_NAMESPACE) {
              strictFail(
                parser,
                "xml: prefix must be bound to " + XML_NAMESPACE + "\nActual: " + parser.attribValue
              );
            } else if (local === "xmlns" && parser.attribValue !== XMLNS_NAMESPACE) {
              strictFail(
                parser,
                "xmlns: prefix must be bound to " + XMLNS_NAMESPACE + "\nActual: " + parser.attribValue
              );
            } else {
              var tag = parser.tag;
              var parent = parser.tags[parser.tags.length - 1] || parser;
              if (tag.ns === parent.ns) {
                tag.ns = Object.create(parent.ns);
              }
              tag.ns[local] = parser.attribValue;
            }
          }
          parser.attribList.push([parser.attribName, parser.attribValue]);
        } else {
          parser.tag.attributes[parser.attribName] = parser.attribValue;
          emitNode(parser, "onattribute", {
            name: parser.attribName,
            value: parser.attribValue
          });
        }
        parser.attribName = parser.attribValue = "";
      }
      function openTag(parser, selfClosing) {
        if (parser.opt.xmlns) {
          var tag = parser.tag;
          var qn = qname(parser.tagName);
          tag.prefix = qn.prefix;
          tag.local = qn.local;
          tag.uri = tag.ns[qn.prefix] || "";
          if (tag.prefix && !tag.uri) {
            strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(parser.tagName));
            tag.uri = qn.prefix;
          }
          var parent = parser.tags[parser.tags.length - 1] || parser;
          if (tag.ns && parent.ns !== tag.ns) {
            Object.keys(tag.ns).forEach(function(p) {
              emitNode(parser, "onopennamespace", {
                prefix: p,
                uri: tag.ns[p]
              });
            });
          }
          for (var i = 0, l = parser.attribList.length; i < l; i++) {
            var nv = parser.attribList[i];
            var name = nv[0];
            var value = nv[1];
            var qualName = qname(name, true);
            var prefix = qualName.prefix;
            var local = qualName.local;
            var uri = prefix === "" ? "" : tag.ns[prefix] || "";
            var a = {
              name,
              value,
              prefix,
              local,
              uri
            };
            if (prefix && prefix !== "xmlns" && !uri) {
              strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(prefix));
              a.uri = prefix;
            }
            parser.tag.attributes[name] = a;
            emitNode(parser, "onattribute", a);
          }
          parser.attribList.length = 0;
        }
        parser.tag.isSelfClosing = !!selfClosing;
        parser.sawRoot = true;
        parser.tags.push(parser.tag);
        emitNode(parser, "onopentag", parser.tag);
        if (!selfClosing) {
          if (!parser.noscript && parser.tagName.toLowerCase() === "script") {
            parser.state = S.SCRIPT;
          } else {
            parser.state = S.TEXT;
          }
          parser.tag = null;
          parser.tagName = "";
        }
        parser.attribName = parser.attribValue = "";
        parser.attribList.length = 0;
      }
      function closeTag(parser) {
        if (!parser.tagName) {
          strictFail(parser, "Weird empty close tag.");
          parser.textNode += "</>";
          parser.state = S.TEXT;
          return;
        }
        if (parser.script) {
          if (parser.tagName !== "script") {
            parser.script += "</" + parser.tagName + ">";
            parser.tagName = "";
            parser.state = S.SCRIPT;
            return;
          }
          emitNode(parser, "onscript", parser.script);
          parser.script = "";
        }
        var t = parser.tags.length;
        var tagName = parser.tagName;
        if (!parser.strict) {
          tagName = tagName[parser.looseCase]();
        }
        var closeTo = tagName;
        while (t--) {
          var close = parser.tags[t];
          if (close.name !== closeTo) {
            strictFail(parser, "Unexpected close tag");
          } else {
            break;
          }
        }
        if (t < 0) {
          strictFail(parser, "Unmatched closing tag: " + parser.tagName);
          parser.textNode += "</" + parser.tagName + ">";
          parser.state = S.TEXT;
          return;
        }
        parser.tagName = tagName;
        var s2 = parser.tags.length;
        while (s2-- > t) {
          var tag = parser.tag = parser.tags.pop();
          parser.tagName = parser.tag.name;
          emitNode(parser, "onclosetag", parser.tagName);
          var x = {};
          for (var i in tag.ns) {
            x[i] = tag.ns[i];
          }
          var parent = parser.tags[parser.tags.length - 1] || parser;
          if (parser.opt.xmlns && tag.ns !== parent.ns) {
            Object.keys(tag.ns).forEach(function(p) {
              var n = tag.ns[p];
              emitNode(parser, "onclosenamespace", { prefix: p, uri: n });
            });
          }
        }
        if (t === 0) parser.closedRoot = true;
        parser.tagName = parser.attribValue = parser.attribName = "";
        parser.attribList.length = 0;
        parser.state = S.TEXT;
      }
      function parseEntity(parser) {
        var entity = parser.entity;
        var entityLC = entity.toLowerCase();
        var num;
        var numStr = "";
        if (parser.ENTITIES[entity]) {
          return parser.ENTITIES[entity];
        }
        if (parser.ENTITIES[entityLC]) {
          return parser.ENTITIES[entityLC];
        }
        entity = entityLC;
        if (entity.charAt(0) === "#") {
          if (entity.charAt(1) === "x") {
            entity = entity.slice(2);
            num = parseInt(entity, 16);
            numStr = num.toString(16);
          } else {
            entity = entity.slice(1);
            num = parseInt(entity, 10);
            numStr = num.toString(10);
          }
        }
        entity = entity.replace(/^0+/, "");
        if (isNaN(num) || numStr.toLowerCase() !== entity) {
          strictFail(parser, "Invalid character entity");
          return "&" + parser.entity + ";";
        }
        return String.fromCodePoint(num);
      }
      function beginWhiteSpace(parser, c) {
        if (c === "<") {
          parser.state = S.OPEN_WAKA;
          parser.startTagPosition = parser.position;
        } else if (!isWhitespace(c)) {
          strictFail(parser, "Non-whitespace before first tag.");
          parser.textNode = c;
          parser.state = S.TEXT;
        }
      }
      function charAt(chunk, i) {
        var result = "";
        if (i < chunk.length) {
          result = chunk.charAt(i);
        }
        return result;
      }
      function write(chunk) {
        var parser = this;
        if (this.error) {
          throw this.error;
        }
        if (parser.closed) {
          return error(
            parser,
            "Cannot write after close. Assign an onready handler."
          );
        }
        if (chunk === null) {
          return end(parser);
        }
        if (typeof chunk === "object") {
          chunk = chunk.toString();
        }
        var i = 0;
        var c = "";
        while (true) {
          c = charAt(chunk, i++);
          parser.c = c;
          if (!c) {
            break;
          }
          if (parser.trackPosition) {
            parser.position++;
            if (c === "\n") {
              parser.line++;
              parser.column = 0;
            } else {
              parser.column++;
            }
          }
          switch (parser.state) {
            case S.BEGIN:
              parser.state = S.BEGIN_WHITESPACE;
              if (c === "\uFEFF") {
                continue;
              }
              beginWhiteSpace(parser, c);
              continue;
            case S.BEGIN_WHITESPACE:
              beginWhiteSpace(parser, c);
              continue;
            case S.TEXT:
              if (parser.sawRoot && !parser.closedRoot) {
                var starti = i - 1;
                while (c && c !== "<" && c !== "&") {
                  c = charAt(chunk, i++);
                  if (c && parser.trackPosition) {
                    parser.position++;
                    if (c === "\n") {
                      parser.line++;
                      parser.column = 0;
                    } else {
                      parser.column++;
                    }
                  }
                }
                parser.textNode += chunk.substring(starti, i - 1);
              }
              if (c === "<" && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
                parser.state = S.OPEN_WAKA;
                parser.startTagPosition = parser.position;
              } else {
                if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {
                  strictFail(parser, "Text data outside of root node.");
                }
                if (c === "&") {
                  parser.state = S.TEXT_ENTITY;
                } else {
                  parser.textNode += c;
                }
              }
              continue;
            case S.SCRIPT:
              if (c === "<") {
                parser.state = S.SCRIPT_ENDING;
              } else {
                parser.script += c;
              }
              continue;
            case S.SCRIPT_ENDING:
              if (c === "/") {
                parser.state = S.CLOSE_TAG;
              } else {
                parser.script += "<" + c;
                parser.state = S.SCRIPT;
              }
              continue;
            case S.OPEN_WAKA:
              if (c === "!") {
                parser.state = S.SGML_DECL;
                parser.sgmlDecl = "";
              } else if (isWhitespace(c)) {
              } else if (isMatch(nameStart, c)) {
                parser.state = S.OPEN_TAG;
                parser.tagName = c;
              } else if (c === "/") {
                parser.state = S.CLOSE_TAG;
                parser.tagName = "";
              } else if (c === "?") {
                parser.state = S.PROC_INST;
                parser.procInstName = parser.procInstBody = "";
              } else {
                strictFail(parser, "Unencoded <");
                if (parser.startTagPosition + 1 < parser.position) {
                  var pad = parser.position - parser.startTagPosition;
                  c = new Array(pad).join(" ") + c;
                }
                parser.textNode += "<" + c;
                parser.state = S.TEXT;
              }
              continue;
            case S.SGML_DECL:
              if (parser.sgmlDecl + c === "--") {
                parser.state = S.COMMENT;
                parser.comment = "";
                parser.sgmlDecl = "";
                continue;
              }
              if (parser.doctype && parser.doctype !== true && parser.sgmlDecl) {
                parser.state = S.DOCTYPE_DTD;
                parser.doctype += "<!" + parser.sgmlDecl + c;
                parser.sgmlDecl = "";
              } else if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
                emitNode(parser, "onopencdata");
                parser.state = S.CDATA;
                parser.sgmlDecl = "";
                parser.cdata = "";
              } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
                parser.state = S.DOCTYPE;
                if (parser.doctype || parser.sawRoot) {
                  strictFail(
                    parser,
                    "Inappropriately located doctype declaration"
                  );
                }
                parser.doctype = "";
                parser.sgmlDecl = "";
              } else if (c === ">") {
                emitNode(parser, "onsgmldeclaration", parser.sgmlDecl);
                parser.sgmlDecl = "";
                parser.state = S.TEXT;
              } else if (isQuote(c)) {
                parser.state = S.SGML_DECL_QUOTED;
                parser.sgmlDecl += c;
              } else {
                parser.sgmlDecl += c;
              }
              continue;
            case S.SGML_DECL_QUOTED:
              if (c === parser.q) {
                parser.state = S.SGML_DECL;
                parser.q = "";
              }
              parser.sgmlDecl += c;
              continue;
            case S.DOCTYPE:
              if (c === ">") {
                parser.state = S.TEXT;
                emitNode(parser, "ondoctype", parser.doctype);
                parser.doctype = true;
              } else {
                parser.doctype += c;
                if (c === "[") {
                  parser.state = S.DOCTYPE_DTD;
                } else if (isQuote(c)) {
                  parser.state = S.DOCTYPE_QUOTED;
                  parser.q = c;
                }
              }
              continue;
            case S.DOCTYPE_QUOTED:
              parser.doctype += c;
              if (c === parser.q) {
                parser.q = "";
                parser.state = S.DOCTYPE;
              }
              continue;
            case S.DOCTYPE_DTD:
              if (c === "]") {
                parser.doctype += c;
                parser.state = S.DOCTYPE;
              } else if (c === "<") {
                parser.state = S.OPEN_WAKA;
                parser.startTagPosition = parser.position;
              } else if (isQuote(c)) {
                parser.doctype += c;
                parser.state = S.DOCTYPE_DTD_QUOTED;
                parser.q = c;
              } else {
                parser.doctype += c;
              }
              continue;
            case S.DOCTYPE_DTD_QUOTED:
              parser.doctype += c;
              if (c === parser.q) {
                parser.state = S.DOCTYPE_DTD;
                parser.q = "";
              }
              continue;
            case S.COMMENT:
              if (c === "-") {
                parser.state = S.COMMENT_ENDING;
              } else {
                parser.comment += c;
              }
              continue;
            case S.COMMENT_ENDING:
              if (c === "-") {
                parser.state = S.COMMENT_ENDED;
                parser.comment = textopts(parser.opt, parser.comment);
                if (parser.comment) {
                  emitNode(parser, "oncomment", parser.comment);
                }
                parser.comment = "";
              } else {
                parser.comment += "-" + c;
                parser.state = S.COMMENT;
              }
              continue;
            case S.COMMENT_ENDED:
              if (c !== ">") {
                strictFail(parser, "Malformed comment");
                parser.comment += "--" + c;
                parser.state = S.COMMENT;
              } else if (parser.doctype && parser.doctype !== true) {
                parser.state = S.DOCTYPE_DTD;
              } else {
                parser.state = S.TEXT;
              }
              continue;
            case S.CDATA:
              if (c === "]") {
                parser.state = S.CDATA_ENDING;
              } else {
                parser.cdata += c;
              }
              continue;
            case S.CDATA_ENDING:
              if (c === "]") {
                parser.state = S.CDATA_ENDING_2;
              } else {
                parser.cdata += "]" + c;
                parser.state = S.CDATA;
              }
              continue;
            case S.CDATA_ENDING_2:
              if (c === ">") {
                if (parser.cdata) {
                  emitNode(parser, "oncdata", parser.cdata);
                }
                emitNode(parser, "onclosecdata");
                parser.cdata = "";
                parser.state = S.TEXT;
              } else if (c === "]") {
                parser.cdata += "]";
              } else {
                parser.cdata += "]]" + c;
                parser.state = S.CDATA;
              }
              continue;
            case S.PROC_INST:
              if (c === "?") {
                parser.state = S.PROC_INST_ENDING;
              } else if (isWhitespace(c)) {
                parser.state = S.PROC_INST_BODY;
              } else {
                parser.procInstName += c;
              }
              continue;
            case S.PROC_INST_BODY:
              if (!parser.procInstBody && isWhitespace(c)) {
                continue;
              } else if (c === "?") {
                parser.state = S.PROC_INST_ENDING;
              } else {
                parser.procInstBody += c;
              }
              continue;
            case S.PROC_INST_ENDING:
              if (c === ">") {
                emitNode(parser, "onprocessinginstruction", {
                  name: parser.procInstName,
                  body: parser.procInstBody
                });
                parser.procInstName = parser.procInstBody = "";
                parser.state = S.TEXT;
              } else {
                parser.procInstBody += "?" + c;
                parser.state = S.PROC_INST_BODY;
              }
              continue;
            case S.OPEN_TAG:
              if (isMatch(nameBody, c)) {
                parser.tagName += c;
              } else {
                newTag(parser);
                if (c === ">") {
                  openTag(parser);
                } else if (c === "/") {
                  parser.state = S.OPEN_TAG_SLASH;
                } else {
                  if (!isWhitespace(c)) {
                    strictFail(parser, "Invalid character in tag name");
                  }
                  parser.state = S.ATTRIB;
                }
              }
              continue;
            case S.OPEN_TAG_SLASH:
              if (c === ">") {
                openTag(parser, true);
                closeTag(parser);
              } else {
                strictFail(parser, "Forward-slash in opening tag not followed by >");
                parser.state = S.ATTRIB;
              }
              continue;
            case S.ATTRIB:
              if (isWhitespace(c)) {
                continue;
              } else if (c === ">") {
                openTag(parser);
              } else if (c === "/") {
                parser.state = S.OPEN_TAG_SLASH;
              } else if (isMatch(nameStart, c)) {
                parser.attribName = c;
                parser.attribValue = "";
                parser.state = S.ATTRIB_NAME;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S.ATTRIB_NAME:
              if (c === "=") {
                parser.state = S.ATTRIB_VALUE;
              } else if (c === ">") {
                strictFail(parser, "Attribute without value");
                parser.attribValue = parser.attribName;
                attrib(parser);
                openTag(parser);
              } else if (isWhitespace(c)) {
                parser.state = S.ATTRIB_NAME_SAW_WHITE;
              } else if (isMatch(nameBody, c)) {
                parser.attribName += c;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S.ATTRIB_NAME_SAW_WHITE:
              if (c === "=") {
                parser.state = S.ATTRIB_VALUE;
              } else if (isWhitespace(c)) {
                continue;
              } else {
                strictFail(parser, "Attribute without value");
                parser.tag.attributes[parser.attribName] = "";
                parser.attribValue = "";
                emitNode(parser, "onattribute", {
                  name: parser.attribName,
                  value: ""
                });
                parser.attribName = "";
                if (c === ">") {
                  openTag(parser);
                } else if (isMatch(nameStart, c)) {
                  parser.attribName = c;
                  parser.state = S.ATTRIB_NAME;
                } else {
                  strictFail(parser, "Invalid attribute name");
                  parser.state = S.ATTRIB;
                }
              }
              continue;
            case S.ATTRIB_VALUE:
              if (isWhitespace(c)) {
                continue;
              } else if (isQuote(c)) {
                parser.q = c;
                parser.state = S.ATTRIB_VALUE_QUOTED;
              } else {
                if (!parser.opt.unquotedAttributeValues) {
                  error(parser, "Unquoted attribute value");
                }
                parser.state = S.ATTRIB_VALUE_UNQUOTED;
                parser.attribValue = c;
              }
              continue;
            case S.ATTRIB_VALUE_QUOTED:
              if (c !== parser.q) {
                if (c === "&") {
                  parser.state = S.ATTRIB_VALUE_ENTITY_Q;
                } else {
                  parser.attribValue += c;
                }
                continue;
              }
              attrib(parser);
              parser.q = "";
              parser.state = S.ATTRIB_VALUE_CLOSED;
              continue;
            case S.ATTRIB_VALUE_CLOSED:
              if (isWhitespace(c)) {
                parser.state = S.ATTRIB;
              } else if (c === ">") {
                openTag(parser);
              } else if (c === "/") {
                parser.state = S.OPEN_TAG_SLASH;
              } else if (isMatch(nameStart, c)) {
                strictFail(parser, "No whitespace between attributes");
                parser.attribName = c;
                parser.attribValue = "";
                parser.state = S.ATTRIB_NAME;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S.ATTRIB_VALUE_UNQUOTED:
              if (!isAttribEnd(c)) {
                if (c === "&") {
                  parser.state = S.ATTRIB_VALUE_ENTITY_U;
                } else {
                  parser.attribValue += c;
                }
                continue;
              }
              attrib(parser);
              if (c === ">") {
                openTag(parser);
              } else {
                parser.state = S.ATTRIB;
              }
              continue;
            case S.CLOSE_TAG:
              if (!parser.tagName) {
                if (isWhitespace(c)) {
                  continue;
                } else if (notMatch(nameStart, c)) {
                  if (parser.script) {
                    parser.script += "</" + c;
                    parser.state = S.SCRIPT;
                  } else {
                    strictFail(parser, "Invalid tagname in closing tag.");
                  }
                } else {
                  parser.tagName = c;
                }
              } else if (c === ">") {
                closeTag(parser);
              } else if (isMatch(nameBody, c)) {
                parser.tagName += c;
              } else if (parser.script) {
                parser.script += "</" + parser.tagName;
                parser.tagName = "";
                parser.state = S.SCRIPT;
              } else {
                if (!isWhitespace(c)) {
                  strictFail(parser, "Invalid tagname in closing tag");
                }
                parser.state = S.CLOSE_TAG_SAW_WHITE;
              }
              continue;
            case S.CLOSE_TAG_SAW_WHITE:
              if (isWhitespace(c)) {
                continue;
              }
              if (c === ">") {
                closeTag(parser);
              } else {
                strictFail(parser, "Invalid characters in closing tag");
              }
              continue;
            case S.TEXT_ENTITY:
            case S.ATTRIB_VALUE_ENTITY_Q:
            case S.ATTRIB_VALUE_ENTITY_U:
              var returnState;
              var buffer;
              switch (parser.state) {
                case S.TEXT_ENTITY:
                  returnState = S.TEXT;
                  buffer = "textNode";
                  break;
                case S.ATTRIB_VALUE_ENTITY_Q:
                  returnState = S.ATTRIB_VALUE_QUOTED;
                  buffer = "attribValue";
                  break;
                case S.ATTRIB_VALUE_ENTITY_U:
                  returnState = S.ATTRIB_VALUE_UNQUOTED;
                  buffer = "attribValue";
                  break;
              }
              if (c === ";") {
                var parsedEntity = parseEntity(parser);
                if (parser.opt.unparsedEntities && !Object.values(sax.XML_ENTITIES).includes(parsedEntity)) {
                  parser.entity = "";
                  parser.state = returnState;
                  parser.write(parsedEntity);
                } else {
                  parser[buffer] += parsedEntity;
                  parser.entity = "";
                  parser.state = returnState;
                }
              } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {
                parser.entity += c;
              } else {
                strictFail(parser, "Invalid character in entity name");
                parser[buffer] += "&" + parser.entity + c;
                parser.entity = "";
                parser.state = returnState;
              }
              continue;
            default: {
              throw new Error(parser, "Unknown state: " + parser.state);
            }
          }
        }
        if (parser.position >= parser.bufferCheckPosition) {
          checkBufferLength(parser);
        }
        return parser;
      }
      if (!String.fromCodePoint) {
        (function() {
          var stringFromCharCode = String.fromCharCode;
          var floor = Math.floor;
          var fromCodePoint = function() {
            var MAX_SIZE = 16384;
            var codeUnits = [];
            var highSurrogate;
            var lowSurrogate;
            var index = -1;
            var length = arguments.length;
            if (!length) {
              return "";
            }
            var result = "";
            while (++index < length) {
              var codePoint = Number(arguments[index]);
              if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
              codePoint < 0 || // not a valid Unicode code point
              codePoint > 1114111 || // not a valid Unicode code point
              floor(codePoint) !== codePoint) {
                throw RangeError("Invalid code point: " + codePoint);
              }
              if (codePoint <= 65535) {
                codeUnits.push(codePoint);
              } else {
                codePoint -= 65536;
                highSurrogate = (codePoint >> 10) + 55296;
                lowSurrogate = codePoint % 1024 + 56320;
                codeUnits.push(highSurrogate, lowSurrogate);
              }
              if (index + 1 === length || codeUnits.length > MAX_SIZE) {
                result += stringFromCharCode.apply(null, codeUnits);
                codeUnits.length = 0;
              }
            }
            return result;
          };
          if (Object.defineProperty) {
            Object.defineProperty(String, "fromCodePoint", {
              value: fromCodePoint,
              configurable: true,
              writable: true
            });
          } else {
            String.fromCodePoint = fromCodePoint;
          }
        })();
      }
    })(typeof exports === "undefined" ? exports.sax = {} : exports);
  }
});

// node_modules/xml-js/lib/array-helper.js
var require_array_helper = __commonJS({
  "node_modules/xml-js/lib/array-helper.js"(exports, module2) {
    module2.exports = {
      isArray: function(value) {
        if (Array.isArray) {
          return Array.isArray(value);
        }
        return Object.prototype.toString.call(value) === "[object Array]";
      }
    };
  }
});

// node_modules/xml-js/lib/options-helper.js
var require_options_helper = __commonJS({
  "node_modules/xml-js/lib/options-helper.js"(exports, module2) {
    var isArray = require_array_helper().isArray;
    module2.exports = {
      copyOptions: function(options) {
        var key, copy = {};
        for (key in options) {
          if (options.hasOwnProperty(key)) {
            copy[key] = options[key];
          }
        }
        return copy;
      },
      ensureFlagExists: function(item, options) {
        if (!(item in options) || typeof options[item] !== "boolean") {
          options[item] = false;
        }
      },
      ensureSpacesExists: function(options) {
        if (!("spaces" in options) || typeof options.spaces !== "number" && typeof options.spaces !== "string") {
          options.spaces = 0;
        }
      },
      ensureAlwaysArrayExists: function(options) {
        if (!("alwaysArray" in options) || typeof options.alwaysArray !== "boolean" && !isArray(options.alwaysArray)) {
          options.alwaysArray = false;
        }
      },
      ensureKeyExists: function(key, options) {
        if (!(key + "Key" in options) || typeof options[key + "Key"] !== "string") {
          options[key + "Key"] = options.compact ? "_" + key : key;
        }
      },
      checkFnExists: function(key, options) {
        return key + "Fn" in options;
      }
    };
  }
});

// node_modules/xml-js/lib/xml2js.js
var require_xml2js = __commonJS({
  "node_modules/xml-js/lib/xml2js.js"(exports, module2) {
    var sax = require_sax();
    var expat = { on: function() {
    }, parse: function() {
    } };
    var helper = require_options_helper();
    var isArray = require_array_helper().isArray;
    var options;
    var pureJsParser = true;
    var currentElement;
    function validateOptions(userOptions) {
      options = helper.copyOptions(userOptions);
      helper.ensureFlagExists("ignoreDeclaration", options);
      helper.ensureFlagExists("ignoreInstruction", options);
      helper.ensureFlagExists("ignoreAttributes", options);
      helper.ensureFlagExists("ignoreText", options);
      helper.ensureFlagExists("ignoreComment", options);
      helper.ensureFlagExists("ignoreCdata", options);
      helper.ensureFlagExists("ignoreDoctype", options);
      helper.ensureFlagExists("compact", options);
      helper.ensureFlagExists("alwaysChildren", options);
      helper.ensureFlagExists("addParent", options);
      helper.ensureFlagExists("trim", options);
      helper.ensureFlagExists("nativeType", options);
      helper.ensureFlagExists("nativeTypeAttributes", options);
      helper.ensureFlagExists("sanitize", options);
      helper.ensureFlagExists("instructionHasAttributes", options);
      helper.ensureFlagExists("captureSpacesBetweenElements", options);
      helper.ensureAlwaysArrayExists(options);
      helper.ensureKeyExists("declaration", options);
      helper.ensureKeyExists("instruction", options);
      helper.ensureKeyExists("attributes", options);
      helper.ensureKeyExists("text", options);
      helper.ensureKeyExists("comment", options);
      helper.ensureKeyExists("cdata", options);
      helper.ensureKeyExists("doctype", options);
      helper.ensureKeyExists("type", options);
      helper.ensureKeyExists("name", options);
      helper.ensureKeyExists("elements", options);
      helper.ensureKeyExists("parent", options);
      helper.checkFnExists("doctype", options);
      helper.checkFnExists("instruction", options);
      helper.checkFnExists("cdata", options);
      helper.checkFnExists("comment", options);
      helper.checkFnExists("text", options);
      helper.checkFnExists("instructionName", options);
      helper.checkFnExists("elementName", options);
      helper.checkFnExists("attributeName", options);
      helper.checkFnExists("attributeValue", options);
      helper.checkFnExists("attributes", options);
      return options;
    }
    function nativeType2(value) {
      var nValue = Number(value);
      if (!isNaN(nValue)) {
        return nValue;
      }
      var bValue = value.toLowerCase();
      if (bValue === "true") {
        return true;
      } else if (bValue === "false") {
        return false;
      }
      return value;
    }
    function addField(type, value) {
      var key;
      if (options.compact) {
        if (!currentElement[options[type + "Key"]] && (isArray(options.alwaysArray) ? options.alwaysArray.indexOf(options[type + "Key"]) !== -1 : options.alwaysArray)) {
          currentElement[options[type + "Key"]] = [];
        }
        if (currentElement[options[type + "Key"]] && !isArray(currentElement[options[type + "Key"]])) {
          currentElement[options[type + "Key"]] = [currentElement[options[type + "Key"]]];
        }
        if (type + "Fn" in options && typeof value === "string") {
          value = options[type + "Fn"](value, currentElement);
        }
        if (type === "instruction" && ("instructionFn" in options || "instructionNameFn" in options)) {
          for (key in value) {
            if (value.hasOwnProperty(key)) {
              if ("instructionFn" in options) {
                value[key] = options.instructionFn(value[key], key, currentElement);
              } else {
                var temp = value[key];
                delete value[key];
                value[options.instructionNameFn(key, temp, currentElement)] = temp;
              }
            }
          }
        }
        if (isArray(currentElement[options[type + "Key"]])) {
          currentElement[options[type + "Key"]].push(value);
        } else {
          currentElement[options[type + "Key"]] = value;
        }
      } else {
        if (!currentElement[options.elementsKey]) {
          currentElement[options.elementsKey] = [];
        }
        var element = {};
        element[options.typeKey] = type;
        if (type === "instruction") {
          for (key in value) {
            if (value.hasOwnProperty(key)) {
              break;
            }
          }
          element[options.nameKey] = "instructionNameFn" in options ? options.instructionNameFn(key, value, currentElement) : key;
          if (options.instructionHasAttributes) {
            element[options.attributesKey] = value[key][options.attributesKey];
            if ("instructionFn" in options) {
              element[options.attributesKey] = options.instructionFn(element[options.attributesKey], key, currentElement);
            }
          } else {
            if ("instructionFn" in options) {
              value[key] = options.instructionFn(value[key], key, currentElement);
            }
            element[options.instructionKey] = value[key];
          }
        } else {
          if (type + "Fn" in options) {
            value = options[type + "Fn"](value, currentElement);
          }
          element[options[type + "Key"]] = value;
        }
        if (options.addParent) {
          element[options.parentKey] = currentElement;
        }
        currentElement[options.elementsKey].push(element);
      }
    }
    function manipulateAttributes(attributes) {
      if ("attributesFn" in options && attributes) {
        attributes = options.attributesFn(attributes, currentElement);
      }
      if ((options.trim || "attributeValueFn" in options || "attributeNameFn" in options || options.nativeTypeAttributes) && attributes) {
        var key;
        for (key in attributes) {
          if (attributes.hasOwnProperty(key)) {
            if (options.trim) attributes[key] = attributes[key].trim();
            if (options.nativeTypeAttributes) {
              attributes[key] = nativeType2(attributes[key]);
            }
            if ("attributeValueFn" in options) attributes[key] = options.attributeValueFn(attributes[key], key, currentElement);
            if ("attributeNameFn" in options) {
              var temp = attributes[key];
              delete attributes[key];
              attributes[options.attributeNameFn(key, attributes[key], currentElement)] = temp;
            }
          }
        }
      }
      return attributes;
    }
    function onInstruction(instruction) {
      var attributes = {};
      if (instruction.body && (instruction.name.toLowerCase() === "xml" || options.instructionHasAttributes)) {
        var attrsRegExp = /([\w:-]+)\s*=\s*(?:"([^"]*)"|'([^']*)'|(\w+))\s*/g;
        var match;
        while ((match = attrsRegExp.exec(instruction.body)) !== null) {
          attributes[match[1]] = match[2] || match[3] || match[4];
        }
        attributes = manipulateAttributes(attributes);
      }
      if (instruction.name.toLowerCase() === "xml") {
        if (options.ignoreDeclaration) {
          return;
        }
        currentElement[options.declarationKey] = {};
        if (Object.keys(attributes).length) {
          currentElement[options.declarationKey][options.attributesKey] = attributes;
        }
        if (options.addParent) {
          currentElement[options.declarationKey][options.parentKey] = currentElement;
        }
      } else {
        if (options.ignoreInstruction) {
          return;
        }
        if (options.trim) {
          instruction.body = instruction.body.trim();
        }
        var value = {};
        if (options.instructionHasAttributes && Object.keys(attributes).length) {
          value[instruction.name] = {};
          value[instruction.name][options.attributesKey] = attributes;
        } else {
          value[instruction.name] = instruction.body;
        }
        addField("instruction", value);
      }
    }
    function onStartElement(name, attributes) {
      var element;
      if (typeof name === "object") {
        attributes = name.attributes;
        name = name.name;
      }
      attributes = manipulateAttributes(attributes);
      if ("elementNameFn" in options) {
        name = options.elementNameFn(name, currentElement);
      }
      if (options.compact) {
        element = {};
        if (!options.ignoreAttributes && attributes && Object.keys(attributes).length) {
          element[options.attributesKey] = {};
          var key;
          for (key in attributes) {
            if (attributes.hasOwnProperty(key)) {
              element[options.attributesKey][key] = attributes[key];
            }
          }
        }
        if (!(name in currentElement) && (isArray(options.alwaysArray) ? options.alwaysArray.indexOf(name) !== -1 : options.alwaysArray)) {
          currentElement[name] = [];
        }
        if (currentElement[name] && !isArray(currentElement[name])) {
          currentElement[name] = [currentElement[name]];
        }
        if (isArray(currentElement[name])) {
          currentElement[name].push(element);
        } else {
          currentElement[name] = element;
        }
      } else {
        if (!currentElement[options.elementsKey]) {
          currentElement[options.elementsKey] = [];
        }
        element = {};
        element[options.typeKey] = "element";
        element[options.nameKey] = name;
        if (!options.ignoreAttributes && attributes && Object.keys(attributes).length) {
          element[options.attributesKey] = attributes;
        }
        if (options.alwaysChildren) {
          element[options.elementsKey] = [];
        }
        currentElement[options.elementsKey].push(element);
      }
      element[options.parentKey] = currentElement;
      currentElement = element;
    }
    function onText(text) {
      if (options.ignoreText) {
        return;
      }
      if (!text.trim() && !options.captureSpacesBetweenElements) {
        return;
      }
      if (options.trim) {
        text = text.trim();
      }
      if (options.nativeType) {
        text = nativeType2(text);
      }
      if (options.sanitize) {
        text = text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
      }
      addField("text", text);
    }
    function onComment(comment) {
      if (options.ignoreComment) {
        return;
      }
      if (options.trim) {
        comment = comment.trim();
      }
      addField("comment", comment);
    }
    function onEndElement(name) {
      var parentElement = currentElement[options.parentKey];
      if (!options.addParent) {
        delete currentElement[options.parentKey];
      }
      currentElement = parentElement;
    }
    function onCdata(cdata) {
      if (options.ignoreCdata) {
        return;
      }
      if (options.trim) {
        cdata = cdata.trim();
      }
      addField("cdata", cdata);
    }
    function onDoctype(doctype) {
      if (options.ignoreDoctype) {
        return;
      }
      doctype = doctype.replace(/^ /, "");
      if (options.trim) {
        doctype = doctype.trim();
      }
      addField("doctype", doctype);
    }
    function onError(error) {
      error.note = error;
    }
    module2.exports = function(xml, userOptions) {
      var parser = pureJsParser ? sax.parser(true, {}) : parser = new expat.Parser("UTF-8");
      var result = {};
      currentElement = result;
      options = validateOptions(userOptions);
      if (pureJsParser) {
        parser.opt = { strictEntities: true };
        parser.onopentag = onStartElement;
        parser.ontext = onText;
        parser.oncomment = onComment;
        parser.onclosetag = onEndElement;
        parser.onerror = onError;
        parser.oncdata = onCdata;
        parser.ondoctype = onDoctype;
        parser.onprocessinginstruction = onInstruction;
      } else {
        parser.on("startElement", onStartElement);
        parser.on("text", onText);
        parser.on("comment", onComment);
        parser.on("endElement", onEndElement);
        parser.on("error", onError);
      }
      if (pureJsParser) {
        parser.write(xml).close();
      } else {
        if (!parser.parse(xml)) {
          throw new Error("XML parsing error: " + parser.getError());
        }
      }
      if (result[options.elementsKey]) {
        var temp = result[options.elementsKey];
        delete result[options.elementsKey];
        result[options.elementsKey] = temp;
        delete result.text;
      }
      return result;
    };
  }
});

// node_modules/xml-js/lib/xml2json.js
var require_xml2json = __commonJS({
  "node_modules/xml-js/lib/xml2json.js"(exports, module2) {
    var helper = require_options_helper();
    var xml2js2 = require_xml2js();
    function validateOptions(userOptions) {
      var options = helper.copyOptions(userOptions);
      helper.ensureSpacesExists(options);
      return options;
    }
    module2.exports = function(xml, userOptions) {
      var options, js, json, parentKey;
      options = validateOptions(userOptions);
      js = xml2js2(xml, options);
      parentKey = "compact" in options && options.compact ? "_parent" : "parent";
      if ("addParent" in options && options.addParent) {
        json = JSON.stringify(js, function(k, v) {
          return k === parentKey ? "_" : v;
        }, options.spaces);
      } else {
        json = JSON.stringify(js, null, options.spaces);
      }
      return json.replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
    };
  }
});

// node_modules/xml-js/lib/js2xml.js
var require_js2xml = __commonJS({
  "node_modules/xml-js/lib/js2xml.js"(exports, module2) {
    var helper = require_options_helper();
    var isArray = require_array_helper().isArray;
    var currentElement;
    var currentElementName;
    function validateOptions(userOptions) {
      var options = helper.copyOptions(userOptions);
      helper.ensureFlagExists("ignoreDeclaration", options);
      helper.ensureFlagExists("ignoreInstruction", options);
      helper.ensureFlagExists("ignoreAttributes", options);
      helper.ensureFlagExists("ignoreText", options);
      helper.ensureFlagExists("ignoreComment", options);
      helper.ensureFlagExists("ignoreCdata", options);
      helper.ensureFlagExists("ignoreDoctype", options);
      helper.ensureFlagExists("compact", options);
      helper.ensureFlagExists("indentText", options);
      helper.ensureFlagExists("indentCdata", options);
      helper.ensureFlagExists("indentAttributes", options);
      helper.ensureFlagExists("indentInstruction", options);
      helper.ensureFlagExists("fullTagEmptyElement", options);
      helper.ensureFlagExists("noQuotesForNativeAttributes", options);
      helper.ensureSpacesExists(options);
      if (typeof options.spaces === "number") {
        options.spaces = Array(options.spaces + 1).join(" ");
      }
      helper.ensureKeyExists("declaration", options);
      helper.ensureKeyExists("instruction", options);
      helper.ensureKeyExists("attributes", options);
      helper.ensureKeyExists("text", options);
      helper.ensureKeyExists("comment", options);
      helper.ensureKeyExists("cdata", options);
      helper.ensureKeyExists("doctype", options);
      helper.ensureKeyExists("type", options);
      helper.ensureKeyExists("name", options);
      helper.ensureKeyExists("elements", options);
      helper.checkFnExists("doctype", options);
      helper.checkFnExists("instruction", options);
      helper.checkFnExists("cdata", options);
      helper.checkFnExists("comment", options);
      helper.checkFnExists("text", options);
      helper.checkFnExists("instructionName", options);
      helper.checkFnExists("elementName", options);
      helper.checkFnExists("attributeName", options);
      helper.checkFnExists("attributeValue", options);
      helper.checkFnExists("attributes", options);
      helper.checkFnExists("fullTagEmptyElement", options);
      return options;
    }
    function writeIndentation(options, depth, firstLine) {
      return (!firstLine && options.spaces ? "\n" : "") + Array(depth + 1).join(options.spaces);
    }
    function writeAttributes(attributes, options, depth) {
      if (options.ignoreAttributes) {
        return "";
      }
      if ("attributesFn" in options) {
        attributes = options.attributesFn(attributes, currentElementName, currentElement);
      }
      var key, attr, attrName, quote, result = [];
      for (key in attributes) {
        if (attributes.hasOwnProperty(key) && attributes[key] !== null && attributes[key] !== void 0) {
          quote = options.noQuotesForNativeAttributes && typeof attributes[key] !== "string" ? "" : '"';
          attr = "" + attributes[key];
          attr = attr.replace(/"/g, "&quot;");
          attrName = "attributeNameFn" in options ? options.attributeNameFn(key, attr, currentElementName, currentElement) : key;
          result.push(options.spaces && options.indentAttributes ? writeIndentation(options, depth + 1, false) : " ");
          result.push(attrName + "=" + quote + ("attributeValueFn" in options ? options.attributeValueFn(attr, key, currentElementName, currentElement) : attr) + quote);
        }
      }
      if (attributes && Object.keys(attributes).length && options.spaces && options.indentAttributes) {
        result.push(writeIndentation(options, depth, false));
      }
      return result.join("");
    }
    function writeDeclaration(declaration, options, depth) {
      currentElement = declaration;
      currentElementName = "xml";
      return options.ignoreDeclaration ? "" : "<?xml" + writeAttributes(declaration[options.attributesKey], options, depth) + "?>";
    }
    function writeInstruction(instruction, options, depth) {
      if (options.ignoreInstruction) {
        return "";
      }
      var key;
      for (key in instruction) {
        if (instruction.hasOwnProperty(key)) {
          break;
        }
      }
      var instructionName = "instructionNameFn" in options ? options.instructionNameFn(key, instruction[key], currentElementName, currentElement) : key;
      if (typeof instruction[key] === "object") {
        currentElement = instruction;
        currentElementName = instructionName;
        return "<?" + instructionName + writeAttributes(instruction[key][options.attributesKey], options, depth) + "?>";
      } else {
        var instructionValue = instruction[key] ? instruction[key] : "";
        if ("instructionFn" in options) instructionValue = options.instructionFn(instructionValue, key, currentElementName, currentElement);
        return "<?" + instructionName + (instructionValue ? " " + instructionValue : "") + "?>";
      }
    }
    function writeComment(comment, options) {
      return options.ignoreComment ? "" : "<!--" + ("commentFn" in options ? options.commentFn(comment, currentElementName, currentElement) : comment) + "-->";
    }
    function writeCdata(cdata, options) {
      return options.ignoreCdata ? "" : "<![CDATA[" + ("cdataFn" in options ? options.cdataFn(cdata, currentElementName, currentElement) : cdata.replace("]]>", "]]]]><![CDATA[>")) + "]]>";
    }
    function writeDoctype(doctype, options) {
      return options.ignoreDoctype ? "" : "<!DOCTYPE " + ("doctypeFn" in options ? options.doctypeFn(doctype, currentElementName, currentElement) : doctype) + ">";
    }
    function writeText(text, options) {
      if (options.ignoreText) return "";
      text = "" + text;
      text = text.replace(/&amp;/g, "&");
      text = text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
      return "textFn" in options ? options.textFn(text, currentElementName, currentElement) : text;
    }
    function hasContent(element, options) {
      var i;
      if (element.elements && element.elements.length) {
        for (i = 0; i < element.elements.length; ++i) {
          switch (element.elements[i][options.typeKey]) {
            case "text":
              if (options.indentText) {
                return true;
              }
              break;
            // skip to next key
            case "cdata":
              if (options.indentCdata) {
                return true;
              }
              break;
            // skip to next key
            case "instruction":
              if (options.indentInstruction) {
                return true;
              }
              break;
            // skip to next key
            case "doctype":
            case "comment":
            case "element":
              return true;
            default:
              return true;
          }
        }
      }
      return false;
    }
    function writeElement(element, options, depth) {
      currentElement = element;
      currentElementName = element.name;
      var xml = [], elementName = "elementNameFn" in options ? options.elementNameFn(element.name, element) : element.name;
      xml.push("<" + elementName);
      if (element[options.attributesKey]) {
        xml.push(writeAttributes(element[options.attributesKey], options, depth));
      }
      var withClosingTag = element[options.elementsKey] && element[options.elementsKey].length || element[options.attributesKey] && element[options.attributesKey]["xml:space"] === "preserve";
      if (!withClosingTag) {
        if ("fullTagEmptyElementFn" in options) {
          withClosingTag = options.fullTagEmptyElementFn(element.name, element);
        } else {
          withClosingTag = options.fullTagEmptyElement;
        }
      }
      if (withClosingTag) {
        xml.push(">");
        if (element[options.elementsKey] && element[options.elementsKey].length) {
          xml.push(writeElements(element[options.elementsKey], options, depth + 1));
          currentElement = element;
          currentElementName = element.name;
        }
        xml.push(options.spaces && hasContent(element, options) ? "\n" + Array(depth + 1).join(options.spaces) : "");
        xml.push("</" + elementName + ">");
      } else {
        xml.push("/>");
      }
      return xml.join("");
    }
    function writeElements(elements, options, depth, firstLine) {
      return elements.reduce(function(xml, element) {
        var indent = writeIndentation(options, depth, firstLine && !xml);
        switch (element.type) {
          case "element":
            return xml + indent + writeElement(element, options, depth);
          case "comment":
            return xml + indent + writeComment(element[options.commentKey], options);
          case "doctype":
            return xml + indent + writeDoctype(element[options.doctypeKey], options);
          case "cdata":
            return xml + (options.indentCdata ? indent : "") + writeCdata(element[options.cdataKey], options);
          case "text":
            return xml + (options.indentText ? indent : "") + writeText(element[options.textKey], options);
          case "instruction":
            var instruction = {};
            instruction[element[options.nameKey]] = element[options.attributesKey] ? element : element[options.instructionKey];
            return xml + (options.indentInstruction ? indent : "") + writeInstruction(instruction, options, depth);
        }
      }, "");
    }
    function hasContentCompact(element, options, anyContent) {
      var key;
      for (key in element) {
        if (element.hasOwnProperty(key)) {
          switch (key) {
            case options.parentKey:
            case options.attributesKey:
              break;
            // skip to next key
            case options.textKey:
              if (options.indentText || anyContent) {
                return true;
              }
              break;
            // skip to next key
            case options.cdataKey:
              if (options.indentCdata || anyContent) {
                return true;
              }
              break;
            // skip to next key
            case options.instructionKey:
              if (options.indentInstruction || anyContent) {
                return true;
              }
              break;
            // skip to next key
            case options.doctypeKey:
            case options.commentKey:
              return true;
            default:
              return true;
          }
        }
      }
      return false;
    }
    function writeElementCompact(element, name, options, depth, indent) {
      currentElement = element;
      currentElementName = name;
      var elementName = "elementNameFn" in options ? options.elementNameFn(name, element) : name;
      if (typeof element === "undefined" || element === null || element === "") {
        return "fullTagEmptyElementFn" in options && options.fullTagEmptyElementFn(name, element) || options.fullTagEmptyElement ? "<" + elementName + "></" + elementName + ">" : "<" + elementName + "/>";
      }
      var xml = [];
      if (name) {
        xml.push("<" + elementName);
        if (typeof element !== "object") {
          xml.push(">" + writeText(element, options) + "</" + elementName + ">");
          return xml.join("");
        }
        if (element[options.attributesKey]) {
          xml.push(writeAttributes(element[options.attributesKey], options, depth));
        }
        var withClosingTag = hasContentCompact(element, options, true) || element[options.attributesKey] && element[options.attributesKey]["xml:space"] === "preserve";
        if (!withClosingTag) {
          if ("fullTagEmptyElementFn" in options) {
            withClosingTag = options.fullTagEmptyElementFn(name, element);
          } else {
            withClosingTag = options.fullTagEmptyElement;
          }
        }
        if (withClosingTag) {
          xml.push(">");
        } else {
          xml.push("/>");
          return xml.join("");
        }
      }
      xml.push(writeElementsCompact(element, options, depth + 1, false));
      currentElement = element;
      currentElementName = name;
      if (name) {
        xml.push((indent ? writeIndentation(options, depth, false) : "") + "</" + elementName + ">");
      }
      return xml.join("");
    }
    function writeElementsCompact(element, options, depth, firstLine) {
      var i, key, nodes, xml = [];
      for (key in element) {
        if (element.hasOwnProperty(key)) {
          nodes = isArray(element[key]) ? element[key] : [element[key]];
          for (i = 0; i < nodes.length; ++i) {
            switch (key) {
              case options.declarationKey:
                xml.push(writeDeclaration(nodes[i], options, depth));
                break;
              case options.instructionKey:
                xml.push((options.indentInstruction ? writeIndentation(options, depth, firstLine) : "") + writeInstruction(nodes[i], options, depth));
                break;
              case options.attributesKey:
              case options.parentKey:
                break;
              // skip
              case options.textKey:
                xml.push((options.indentText ? writeIndentation(options, depth, firstLine) : "") + writeText(nodes[i], options));
                break;
              case options.cdataKey:
                xml.push((options.indentCdata ? writeIndentation(options, depth, firstLine) : "") + writeCdata(nodes[i], options));
                break;
              case options.doctypeKey:
                xml.push(writeIndentation(options, depth, firstLine) + writeDoctype(nodes[i], options));
                break;
              case options.commentKey:
                xml.push(writeIndentation(options, depth, firstLine) + writeComment(nodes[i], options));
                break;
              default:
                xml.push(writeIndentation(options, depth, firstLine) + writeElementCompact(nodes[i], key, options, depth, hasContentCompact(nodes[i], options)));
            }
            firstLine = firstLine && !xml.length;
          }
        }
      }
      return xml.join("");
    }
    module2.exports = function(js, options) {
      options = validateOptions(options);
      var xml = [];
      currentElement = js;
      currentElementName = "_root_";
      if (options.compact) {
        xml.push(writeElementsCompact(js, options, 0, true));
      } else {
        if (js[options.declarationKey]) {
          xml.push(writeDeclaration(js[options.declarationKey], options, 0));
        }
        if (js[options.elementsKey] && js[options.elementsKey].length) {
          xml.push(writeElements(js[options.elementsKey], options, 0, !xml.length));
        }
      }
      return xml.join("");
    };
  }
});

// node_modules/xml-js/lib/json2xml.js
var require_json2xml = __commonJS({
  "node_modules/xml-js/lib/json2xml.js"(exports, module2) {
    var js2xml2 = require_js2xml();
    module2.exports = function(json, options) {
      if (json instanceof Buffer) {
        json = json.toString();
      }
      var js = null;
      if (typeof json === "string") {
        try {
          js = JSON.parse(json);
        } catch (e) {
          throw new Error("The JSON structure is invalid");
        }
      } else {
        js = json;
      }
      return js2xml2(js, options);
    };
  }
});

// node_modules/xml-js/lib/index.js
var require_lib = __commonJS({
  "node_modules/xml-js/lib/index.js"(exports, module2) {
    var xml2js2 = require_xml2js();
    var xml2json = require_xml2json();
    var js2xml2 = require_js2xml();
    var json2xml = require_json2xml();
    module2.exports = {
      xml2js: xml2js2,
      xml2json,
      js2xml: js2xml2,
      json2xml
    };
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ICloudContacts
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// src/parser.ts
var import_vcf = __toESM(require_vcard());
function parseVCardToJCardAndFullName(vcardString) {
  const jCard = parseVCardToJCard(vcardString);
  return {
    jCard,
    fullName: getFullName(jCard)
  };
}
function parseVCardToJCard(vcardString) {
  const jCard = (0, import_vcf.parse)(vcardString)[0].toJSON();
  return jCard[1].map((item) => {
    const key = item[0];
    let value = item[3];
    if (key === "org") value = item[3].split(";");
    return {
      key,
      meta: item[1],
      type: item[2],
      value
    };
  });
}
function getFullName(jCard) {
  var _a, _b;
  const fullName = jCard.find(({ key }) => key === "fn");
  if (fullName && fullName.value) {
    return fullName.value.replace(/\\/g, "");
  }
  const isOrg = ((_a = jCard.find(({ key }) => key === "xAbShowAs")) == null ? void 0 : _a.value) === "COMPANY";
  if (isOrg) {
    return ((_b = jCard.find(({ key }) => key === "org")) == null ? void 0 : _b.value)[0].replace(/\\/g, "");
  }
  const name = jCard.find(({ key }) => key === "n");
  if (!name) throw new Error("Unable to get full name");
  return convertNameToFullName(name.value).replace(/\\/g, "");
}
function convertNameToFullName([
  familyName,
  givenName,
  additionalMiddleNames,
  honorificPrefixes,
  honorificSuffixes
]) {
  return [
    honorificPrefixes,
    givenName,
    additionalMiddleNames,
    familyName,
    honorificSuffixes
  ].filter((p) => !!p).join(" ");
}

// src/frontMatter.ts
function createFrontmatter(iCloudVCardData, settings) {
  const { jCard, fullName } = parseVCardToJCardAndFullName(iCloudVCardData);
  return createFrontmatterFromParsedVCard(
    jCard,
    fullName,
    settings
  );
}
function createFrontmatterFromParsedVCard(parsedVCards, fullName, {
  telLabels,
  emailLabels,
  urlLabels,
  relatedLabels,
  addressLabels,
  excludedKeys
}) {
  const labels = parsedVCards.filter(({ key }) => key === "xAbLabel");
  const contact = parsedVCards.reduce(
    (o, { key, value, meta }) => {
      if (excludedKeys.split(/\s+/).indexOf(key) > -1) return o;
      if (key === "fn") return o;
      if (key === "org") return addOrganizationAndDepartement(value, o);
      const rawLabel = getLabel(meta, labels);
      const label = rawLabel ? capitalize(rawLabel) : void 0;
      if (key === "tel")
        return addValueToArray(
          "telephone",
          telLabels && label ? `${label}: ${value}` : value,
          o
        );
      if (key === "email")
        return addValueToArray(
          "email",
          emailLabels && label ? `${label}: ${value}` : value,
          o
        );
      if (key === "adr")
        return addAddresses(
          value,
          o,
          addressLabels ? label : void 0
        );
      if (key === "url")
        return addValueToArray(
          "url",
          urlLabels && label ? `${label}: ${value}` : value,
          o
        );
      if (key === "xAbrelatednames")
        return addValueToArray(
          "related names",
          wrapInBrackets(
            value,
            relatedLabels && label ? label : void 0
          ),
          o
        );
      if (key === "impp")
        return addValueToArray(
          "instant message",
          `${meta.xServiceType}: ${value.replace("xmpp:", "").replace("x-apple:", "")}`,
          o
        );
      if (key === "xSocialprofile")
        return addValueToArray(
          "social profile",
          `${meta.type ? `${capitalize(meta.type)}: ` : ""}${stripSocialValue(value)}`,
          o
        );
      if (key === "xAbdate")
        return addValueToArray(
          "date",
          label ? `${label}: ${value}` : value,
          o
        );
      if (key === "bday") return { ...o, birthday: value };
      return { ...o, [key]: value };
    },
    { name: fullName }
  );
  return contact;
}
function stripSocialValue(value) {
  const toRemove = ["x-apple:", "xmpp:"];
  return toRemove.reduce(
    (value2, searchValue) => value2.replace(searchValue, ""),
    value
  );
}
function addAddresses(value, o, label) {
  let address = value.filter((v) => !!v).join(", ");
  if (label) address = `${label}: ${address}`;
  if (Array.isArray(o.addresses))
    return { ...o, addresses: [...o.addresses, address] };
  return {
    ...o,
    addresses: [address]
  };
}
function wrapInBrackets(value, label) {
  return label ? `[[${value}|${label}: ${value}]]` : `[[${value}]]`;
}
function addValueToArray(key, value, o) {
  if (Array.isArray(o[key])) return { ...o, [key]: [...o[key], value] };
  return {
    ...o,
    [key]: [value]
  };
}
function addOrganizationAndDepartement(value, o) {
  const organization = value[0];
  const departement = value[1];
  let newO = o;
  if (organization) {
    newO = {
      ...newO,
      organization
    };
  }
  if (departement) {
    newO = {
      ...newO,
      departement
    };
  }
  return newO;
}
function getLabel(parsedVCardMeta, parsedVCards) {
  if (!parsedVCardMeta.group && !Array.isArray(parsedVCardMeta.type) && !parsedVCardMeta.type) {
    return;
  }
  if (parsedVCardMeta.group) {
    const xAbLabel = parsedVCards.find(
      ({ key, meta }) => key === "xAbLabel" && meta.group === parsedVCardMeta.group
    );
    if (xAbLabel) {
      const value = xAbLabel.value;
      return value.replace("_$!<", "").replace(">!$_", "");
    }
  }
  const type = parsedVCardMeta.type;
  if (Array.isArray(type)) return type.find(isLabel);
  if (!isLabel(type)) return;
  return type;
}
function isLabel(label) {
  return ["cell", "voice", "pref", "internet"].indexOf(label) === -1;
}
function capitalize(str) {
  if (str === "iphone") return "iPhone";
  return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();
}

// src/ICloudContactsApi.ts
var deletedFolder = "Deleted";
var iCloudVCardPropertieName = "iCloudVCard";
var errorsFileName = "Errors";
var pluginName = "iCloud Contacts";
var ICloudContactsApi = class {
  constructor(onlyRequiredFromObsidianApp, settings, fetchContacts2, showNotice2) {
    this.settings = settings;
    this.fetchContacts = fetchContacts2;
    this.showNotice = showNotice2;
    this.newContacts = [];
    this.modifiedContacts = [];
    this.deletedContacts = [];
    this.skippedContacts = [];
    this.app = onlyRequiredFromObsidianApp.app;
    this.normalizePath = onlyRequiredFromObsidianApp.normalizePath;
  }
  async updateContacts(options = { rewriteAll: false }) {
    const haveSettingsChanged = !!this.settings.previousUpdateSettings && !this.isSameSettings(
      this.settings,
      this.settings.previousUpdateSettings
    );
    if (haveSettingsChanged) options.rewriteAll = true;
    const startNotice = this.showNotice(
      `${pluginName}: Updating contacts...`,
      0
    );
    try {
      this.validateSettings();
      await this.getCreateFolder(this.settings.folder);
      let nDots = 0;
      const interval = setInterval(() => {
        if (nDots > 3) nDots = 0;
        const dots = ".".repeat(nDots).padEnd(3, " ");
        startNotice.setMessage(
          `${pluginName}: Downloading contacts${dots}`
        );
        nDots++;
      }, 500);
      const iCloudVCards = await this.fetchContacts(
        this.settings.username,
        this.settings.password,
        this.settings.iCloudServerUrl
      );
      clearInterval(interval);
      const existingContacts = await this.getAllCurrentContacts(
        this.settings.folder
      );
      const previousUpdateData = this.settings.previousUpdateData || [];
      let i = 0;
      for (const iCloudVCard of iCloudVCards) {
        startNotice.setMessage(
          `${pluginName}: Updating contact ${i++} of ${iCloudVCards.length}`
        );
        const previousUpdateVCard = previousUpdateData.find(
          (vCard) => vCard.url === iCloudVCard.url
        );
        const existingContact = existingContacts.find(
          (c) => c.frontmatter[iCloudVCardPropertieName].url === iCloudVCard.url
        );
        await this.processVCard(
          iCloudVCard,
          previousUpdateVCard,
          existingContact,
          options
        );
      }
      await this.moveDeletedContacts(existingContacts, iCloudVCards);
    } catch (e) {
      console.error(e);
      this.handleError("Error when running updateContacts", e, {
        options
      });
    }
    const usedSettings = { ...this.settings };
    const updateData = [
      ...this.newContacts,
      ...this.modifiedContacts,
      ...this.skippedContacts
    ];
    startNotice.hide();
    this.reportHappenings(haveSettingsChanged);
    this.newContacts = [];
    this.modifiedContacts = [];
    this.deletedContacts = [];
    this.skippedContacts = [];
    return { updateData, usedSettings };
  }
  validateSettings() {
    if (!this.settings.username) {
      throw new Error("ICloud username is required in settings");
    }
    if (!this.settings.password) {
      throw new Error(
        "ICloud app specific password is required in settings"
      );
    }
    if (!this.settings.folder) {
      throw new Error("Folder is required in settings");
    }
    const normalizedFolderPath = this.normalizePath(this.settings.folder);
    if (this.settings.folder !== normalizedFolderPath) {
      throw new Error(
        `Folder "${this.settings.folder}" is not valid, How about using "${normalizedFolderPath}"`
      );
    }
  }
  async processVCard(iCloudVCard, previousVCard, existingContact, options) {
    try {
      if (existingContact) {
        const isModified = this.isModified(
          existingContact.frontmatter,
          iCloudVCard
        );
        if (isModified || options.rewriteAll) {
          await this.updateContactFile(
            iCloudVCard,
            existingContact,
            previousVCard
          );
          this.modifiedContacts.push(iCloudVCard);
        } else {
          this.skippedContacts.push(iCloudVCard);
        }
        return;
      }
      await this.createContactFile(iCloudVCard);
      this.newContacts.push(iCloudVCard);
    } catch (e) {
      this.handleError("Error trying to process contact", e, iCloudVCard);
    }
  }
  reportHappenings(haveSettingsChanged) {
    const newCount = this.newContacts.length;
    const modifiedCount = this.modifiedContacts.length;
    const deletedCount = this.deletedContacts.length;
    const skippedCount = this.skippedContacts.length;
    let noticeText = pluginName + ":\n";
    noticeText += `Created ${newCount}
`;
    noticeText += `Modified ${modifiedCount}
`;
    noticeText += `Deleted ${deletedCount}
`;
    noticeText += `Skipped ${skippedCount}
`;
    if (haveSettingsChanged)
      noticeText += "All contacts where updated to reflect new settings";
    if (newCount + modifiedCount + deletedCount === 0)
      noticeText += "Already up to date";
    this.showNotice(noticeText, 7e3);
    console.log(pluginName, {
      newContacts: this.newContacts,
      modifiedContacts: this.modifiedContacts,
      deletedContacts: this.deletedContacts,
      skippedContacts: this.skippedContacts
    });
  }
  async moveDeletedContacts(existingContacts, iCloudVCards) {
    const deletedContacts = existingContacts.filter(
      (c) => !iCloudVCards.some(
        (i) => i.url === c.frontmatter[iCloudVCardPropertieName].url
      )
    );
    this.deletedContacts = deletedContacts.map(
      (c) => c.frontmatter[iCloudVCardPropertieName]
    );
    if (deletedContacts.length > 0) {
      const folderPath = this.settings.folder + "/" + deletedFolder;
      await this.getCreateFolder(folderPath);
    }
    for (const deletedContact of deletedContacts) {
      await this.moveDeletedContact(deletedContact);
    }
  }
  async moveDeletedContact(deletedContact) {
    try {
      const contactFile = this.app.vault.getFileByPath(
        deletedContact.path
      );
      if (!contactFile)
        throw new Error(deletedContact.path + " not found");
      const uniqueFilePath = await this.createUniqeContactFilePath(
        `${deletedFolder}/${contactFile.basename}`
      );
      await this.app.fileManager.renameFile(
        contactFile,
        this.normalizePath(uniqueFilePath)
      );
    } catch (e) {
      this.handleError(
        "Error trying to move deleted contact",
        e,
        deletedContact.frontmatter[iCloudVCardPropertieName]
      );
    }
  }
  isModified(existingFrontmatter, iCloudVCard) {
    return existingFrontmatter[iCloudVCardPropertieName].etag !== iCloudVCard.etag;
  }
  async updateContactFile(iCloudVCard, existingContact, previousVCard) {
    var _a;
    const newFrontMatter = createFrontmatter(
      iCloudVCard.data,
      this.settings
    );
    const contactFile = this.app.vault.getFileByPath(existingContact.path);
    if (!contactFile) {
      throw new Error("contactFile not found");
    }
    const isFullNameModified = existingContact.frontmatter.name !== newFrontMatter.name;
    if (isFullNameModified) {
      const uniqueFilePath = await this.createUniqeContactFilePath(
        newFrontMatter.name
      );
      await this.app.fileManager.renameFile(
        contactFile,
        this.normalizePath(uniqueFilePath)
      );
    }
    let isPrevNameHeading = (_a = this.settings.previousUpdateSettings) == null ? void 0 : _a.isNameHeading;
    if (isPrevNameHeading === void 0) isPrevNameHeading = true;
    const isNameHeading = this.settings.isNameHeading;
    const isRemoveHeading = isPrevNameHeading && !isNameHeading;
    const isAddHeading = !isPrevNameHeading && isNameHeading;
    let searchValue = `# ${existingContact.frontmatter.name}`;
    let replaceValue = `# ${newFrontMatter.name}`;
    if (isRemoveHeading) {
      replaceValue = "";
    } else if (isAddHeading) {
      searchValue = `
---
`;
      replaceValue = `
---
# ${newFrontMatter.name}`;
    }
    if (searchValue !== replaceValue && (isPrevNameHeading || isNameHeading)) {
      await this.app.vault.process(contactFile, (data) => {
        if (!data.endsWith(searchValue)) replaceValue += "\n";
        return data.replace(searchValue, replaceValue);
      });
    }
    const previousData = previousVCard ? previousVCard.data : existingContact.frontmatter[iCloudVCardPropertieName].data;
    const prevFrontMatter = createFrontmatter(
      previousData,
      this.settings.previousUpdateSettings || this.settings
    );
    await this.app.fileManager.processFrontMatter(
      contactFile,
      (fileFrontmatter) => {
        if (prevFrontMatter) {
          for (const [key] of Object.entries(prevFrontMatter)) {
            if (!newFrontMatter[key]) {
              delete fileFrontmatter[key];
            }
          }
        }
        for (const [key, value] of Object.entries(newFrontMatter)) {
          fileFrontmatter[key] = value;
        }
        fileFrontmatter[iCloudVCardPropertieName] = JSON.stringify(iCloudVCard);
      }
    );
  }
  async createContactFile(iCloudVCard) {
    if (!iCloudVCard.data) {
      throw new Error("iCloudVCard.data is undefined");
    }
    const frontMatter = createFrontmatter(iCloudVCard.data, this.settings);
    let filePath = await this.createUniqeContactFilePath(
      frontMatter.name
    );
    const newFile = await this.app.vault.create(
      this.normalizePath(filePath.replace(/\\/g, "")),
      this.settings.isNameHeading ? `# ${frontMatter.name}` : ""
    );
    await this.app.fileManager.processFrontMatter(newFile, (fm) => {
      for (const [key, value] of Object.entries(frontMatter)) {
        fm[key] = value;
      }
      fm[iCloudVCardPropertieName] = JSON.stringify(iCloudVCard);
    });
  }
  async createUniqeContactFilePath(subPath) {
    let filePath = `${this.settings.folder}/${subPath}.md`;
    let i = 1;
    while (true) {
      const fileExists = await this.app.vault.adapter.exists(
        this.normalizePath(filePath),
        true
      );
      if (!fileExists) break;
      i++;
      filePath = `${this.settings.folder}/${subPath} ${i}.md`;
    }
    return filePath;
  }
  async getAllCurrentContacts(folder) {
    const listedFiles = await this.app.vault.adapter.list(folder);
    const contacts = listedFiles.files.filter(
      (path) => path.endsWith(".md") && !path.includes(errorsFileName)
    ).map((path) => ({
      frontmatter: this.getContactProperties(path),
      path
    })).filter((x) => x.frontmatter !== void 0);
    return contacts;
  }
  getContactProperties(filePath) {
    const cache = this.app.metadataCache.getCache(filePath);
    if (!cache) {
      throw new Error(`cache is falsy in ${filePath}`);
    }
    const frontmatter = cache.frontmatter;
    if (!frontmatter || !frontmatter[iCloudVCardPropertieName])
      return void 0;
    if (typeof frontmatter[iCloudVCardPropertieName] === "string") {
      if (frontmatter[iCloudVCardPropertieName])
        frontmatter[iCloudVCardPropertieName] = JSON.parse(
          frontmatter[iCloudVCardPropertieName]
        );
    }
    return frontmatter;
  }
  async getCreateFolder(folderPath) {
    try {
      const folder = this.app.vault.getFolderByPath(folderPath);
      if (folder) return folder;
      return this.app.vault.createFolder(folderPath);
    } catch (error) {
      this.handleError(
        `Error trying to create the ${folderPath} folder`,
        error,
        { folderPath }
      );
    }
  }
  isSameSettings(a, b) {
    const result = Object.entries(a).filter(
      ([key]) => key !== "previousUpdateSettings" && key !== "previousUpdateData"
    ).every(([key, value]) => value == b[key]);
    return result;
  }
  async createErrorFile() {
    const filePath = this.settings.folder + `/${errorsFileName}.md`;
    const file = this.app.vault.getFileByPath(filePath);
    if (file) return file;
    return await this.app.vault.create(filePath, "");
  }
  async handleError(heading, error, data) {
    let errorText = `## ${heading}
### Error message

${error.message}
`;
    if (data)
      errorText += `### Data

\`\`\`json
${JSON.stringify(data)}
\`\`\`
`;
    const errorFile = await this.createErrorFile();
    if (errorFile) {
      await this.app.vault.append(errorFile, errorText);
      await this.app.workspace.getLeaf().openFile(errorFile);
    }
  }
};

// src/iCloudClient.ts
var import_obsidian = require("obsidian");
var convert = __toESM(require_lib());
var DAVAttributeMap = {
  "urn:ietf:params:xml:ns:caldav": "xmlns:c",
  "urn:ietf:params:xml:ns:carddav": "xmlns:card",
  "http://calendarserver.org/ns/": "xmlns:cs",
  "http://apple.com/ns/ical/": "xmlns:ca",
  "DAV:": "xmlns:d"
};
var DAVNamespace = {
  CALENDAR_SERVER: "http://calendarserver.org/ns/",
  CALDAV_APPLE: "http://apple.com/ns/ical/",
  CALDAV: "urn:ietf:params:xml:ns:caldav",
  CARDDAV: "urn:ietf:params:xml:ns:carddav",
  DAV: "DAV:"
};
var DAVNamespaceShort = {
  CALDAV: "c",
  CARDDAV: "card",
  CALENDAR_SERVER: "cs",
  CALDAV_APPLE: "ca",
  DAV: "d"
};
var accountType = "carddav";
async function fetchContacts(username, password, serverUrl) {
  const authHeaders = {
    authorization: `Basic ${btoa(`${username}:${password}`)}`
  };
  const { rootUrl, homeUrl } = await login(serverUrl, authHeaders);
  const addressBooks = await fetchAddressBooks(homeUrl, rootUrl, authHeaders);
  const vCards = await fetchVCards({
    addressBook: addressBooks[0],
    headers: authHeaders
  });
  return vCards;
}
async function login(serverUrl, headers) {
  const rootUrl = await serviceDiscovery(serverUrl, headers);
  const principalUrl = await fetchPrincipalUrl(rootUrl, headers);
  const homeUrl = await fetchHomeUrl(rootUrl, principalUrl, headers);
  return { rootUrl, principalUrl, homeUrl };
}
var fetchVCards = async (params) => {
  const {
    addressBook,
    headers,
    objectUrls,
    urlFilter = (url) => url,
    useMultiGet = true
  } = params;
  const vcardUrls = (objectUrls != null ? objectUrls : (
    // fetch all objects of the calendar
    (await addressBookQuery({
      url: addressBook.url,
      props: { [`${DAVNamespaceShort.DAV}:getetag`]: {} },
      depth: "1",
      headers
    })).map((res) => {
      var _a;
      return res.ok ? (_a = res.href) != null ? _a : "" : "";
    })
  )).map(
    (url) => url.startsWith("http") || !url ? url : new URL(url, addressBook.url).href
  ).filter(urlFilter).map((url) => new URL(url).pathname);
  let vCardResults = [];
  if (vcardUrls.length > 0) {
    if (useMultiGet) {
      vCardResults = await addressBookMultiGet({
        url: addressBook.url,
        props: {
          [`${DAVNamespaceShort.DAV}:getetag`]: {},
          [`${DAVNamespaceShort.CARDDAV}:address-data`]: {}
        },
        objectUrls: vcardUrls,
        depth: "1",
        headers
      });
    } else {
      vCardResults = await addressBookQuery({
        url: addressBook.url,
        props: {
          [`${DAVNamespaceShort.DAV}:getetag`]: {},
          [`${DAVNamespaceShort.CARDDAV}:address-data`]: {}
        },
        depth: "1",
        headers
      });
    }
  }
  return vCardResults.map((res) => {
    var _a, _b, _c, _d, _e, _f;
    return {
      url: new URL((_a = res.href) != null ? _a : "", addressBook.url).href,
      etag: (_b = res.props) == null ? void 0 : _b.getetag,
      data: (_f = (_d = (_c = res.props) == null ? void 0 : _c.addressData) == null ? void 0 : _d._cdata) != null ? _f : (_e = res.props) == null ? void 0 : _e.addressData
    };
  });
};
async function addressBookMultiGet(params) {
  const { url, props, objectUrls, depth, headers } = params;
  return collectionQuery({
    url,
    body: {
      "addressbook-multiget": {
        _attributes: getDAVAttribute([
          DAVNamespace.DAV,
          DAVNamespace.CARDDAV
        ]),
        [`${DAVNamespaceShort.DAV}:prop`]: props,
        [`${DAVNamespaceShort.DAV}:href`]: objectUrls
      }
    },
    defaultNamespace: DAVNamespaceShort.CARDDAV,
    depth,
    headers
  });
}
async function addressBookQuery(params) {
  const { url, props, filters, depth, headers } = params;
  return collectionQuery({
    url,
    body: {
      "addressbook-query": {
        _attributes: getDAVAttribute([
          DAVNamespace.CARDDAV,
          DAVNamespace.DAV
        ]),
        [`${DAVNamespaceShort.DAV}:prop`]: props,
        filter: filters != null ? filters : {
          "prop-filter": {
            _attributes: {
              name: "FN"
            }
          }
        }
      }
    },
    defaultNamespace: DAVNamespaceShort.CARDDAV,
    depth,
    headers
  });
}
async function collectionQuery(params) {
  const {
    url,
    body,
    depth,
    defaultNamespace = DAVNamespaceShort.DAV,
    headers
  } = params;
  const queryResults = await davRequest({
    url,
    init: {
      method: "REPORT",
      headers: cleanupFalsy({ depth, ...headers }),
      namespace: defaultNamespace,
      body
    }
  });
  if (queryResults.length === 1 && !queryResults[0].raw) {
    return [];
  }
  return queryResults;
}
async function fetchAddressBooks(homeUrl, rootUrl, headers) {
  const res = await propfind({
    url: homeUrl,
    props: {
      [`${DAVNamespaceShort.DAV}:displayname`]: {},
      [`${DAVNamespaceShort.CALENDAR_SERVER}:getctag`]: {},
      [`${DAVNamespaceShort.DAV}:resourcetype`]: {},
      [`${DAVNamespaceShort.DAV}:sync-token`]: {}
    },
    depth: "1",
    headers
  });
  return Promise.all(
    res.filter(
      (r) => {
        var _a, _b;
        return Object.keys((_b = (_a = r.props) == null ? void 0 : _a.resourcetype) != null ? _b : {}).includes(
          "addressbook"
        );
      }
    ).map((rs) => {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      const displayName = (_d = (_b = (_a = rs.props) == null ? void 0 : _a.displayname) == null ? void 0 : _b._cdata) != null ? _d : (_c = rs.props) == null ? void 0 : _c.displayname;
      return {
        url: new URL((_e = rs.href) != null ? _e : "", rootUrl != null ? rootUrl : "").href,
        ctag: (_f = rs.props) == null ? void 0 : _f.getctag,
        displayName: typeof displayName === "string" ? displayName : "",
        resourcetype: Object.keys((_g = rs.props) == null ? void 0 : _g.resourcetype),
        syncToken: (_h = rs.props) == null ? void 0 : _h.syncToken
      };
    }).map(async (addr) => ({
      ...addr,
      reports: await supportedReportSet({
        collection: addr,
        headers
      })
    }))
  );
}
async function serviceDiscovery(serverUrl, headers) {
  const endpoint = new URL(serverUrl);
  const uri = new URL(`/.well-known/${accountType}`, endpoint);
  try {
    const response = await (0, import_obsidian.requestUrl)({
      url: uri.href,
      headers,
      method: "PROPFIND"
    });
    if (response.status >= 300 && response.status < 400) {
      const location = response.headers.Location;
      if (typeof location === "string" && location.length) {
        const serviceURL = new URL(location, endpoint);
        if (serviceURL.hostname === uri.hostname && uri.port && !serviceURL.port) {
          serviceURL.port = uri.port;
        }
        serviceURL.protocol = endpoint.protocol !== null && endpoint.protocol !== void 0 ? endpoint.protocol : "http";
        return serviceURL.href;
      }
    }
  } catch (error) {
    console.error(error);
  }
  return endpoint.href;
}
async function fetchPrincipalUrl(rootUrl, headers) {
  var _a, _b, _c;
  const [response] = await propfind({
    url: rootUrl,
    props: {
      [`${DAVNamespaceShort.DAV}:current-user-principal`]: {}
    },
    depth: "0",
    headers
  });
  if (!response.ok) {
    if (response.status === 401) {
      throw new Error("Invalid credentials");
    }
  }
  return new URL((_c = (_b = (_a = response.props) == null ? void 0 : _a.currentUserPrincipal) == null ? void 0 : _b.href) != null ? _c : "", rootUrl).href;
}
async function fetchHomeUrl(rootUrl, principalUrl, headers) {
  var _a;
  const responses = await propfind({
    url: principalUrl,
    props: {
      [`${DAVNamespaceShort.CARDDAV}:addressbook-home-set`]: {}
    },
    depth: "0",
    headers
  });
  const matched = responses.find(
    (r) => urlContains(principalUrl, r.href)
  );
  if (!matched || !matched.ok) {
    throw new Error("cannot find homeUrl");
  }
  return new URL((_a = matched == null ? void 0 : matched.props) == null ? void 0 : _a.addressbookHomeSet.href, rootUrl).href;
}
async function propfind(params) {
  const { url, props, depth, headers } = params;
  return davRequest({
    url,
    init: {
      method: "PROPFIND",
      headers: cleanupFalsy(Object.assign({ depth }, headers)),
      namespace: DAVNamespaceShort.DAV,
      body: {
        propfind: {
          _attributes: getDAVAttribute([
            DAVNamespace.CALDAV,
            DAVNamespace.CALDAV_APPLE,
            DAVNamespace.CALENDAR_SERVER,
            DAVNamespace.CARDDAV,
            DAVNamespace.DAV
          ]),
          prop: props
        }
      }
    }
  });
}
function cleanupFalsy(obj) {
  return Object.entries(obj).reduce((prev, [key, value]) => {
    if (value)
      return Object.assign(Object.assign({}, prev), { [key]: value });
    return prev;
  }, {});
}
function getDAVAttribute(nsArr) {
  return nsArr.reduce(
    (prev, curr) => Object.assign(Object.assign({}, prev), {
      //@ts-ignore
      [DAVAttributeMap[curr]]: curr
    }),
    {}
  );
}
async function davRequest(params) {
  const { url, init, convertIncoming = true, parseOutgoing = true } = params;
  const { headers = {}, body, namespace, method, attributes } = init;
  const xmlBody = convertIncoming ? convert.js2xml(
    {
      _declaration: {
        _attributes: { version: "1.0", encoding: "utf-8" }
      },
      ...body,
      _attributes: attributes
    },
    {
      compact: true,
      spaces: 2,
      elementNameFn: (name) => {
        if (namespace && !/^.+:.+/.test(name)) {
          return `${namespace}:${name}`;
        }
        return name;
      }
    }
  ) : body;
  const davResponse = await (0, import_obsidian.requestUrl)({
    url,
    headers: Object.assign(
      { "Content-Type": "text/xml;charset=UTF-8" },
      cleanupFalsy(headers)
    ),
    body: xmlBody,
    method
  });
  const resText = davResponse.text;
  const result = convert.xml2js(resText, {
    compact: true,
    trim: true,
    textFn: (value, parentElement) => {
      try {
        const parentOfParent = parentElement._parent;
        const pOpKeys = Object.keys(parentOfParent);
        const keyNo = pOpKeys.length;
        const keyName = pOpKeys[keyNo - 1];
        const arrOfKey = parentOfParent[keyName];
        const arrOfKeyLen = arrOfKey.length;
        if (arrOfKeyLen > 0) {
          const arr = arrOfKey;
          const arrIndex = arrOfKey.length - 1;
          arr[arrIndex] = nativeType(value);
        } else {
          parentOfParent[keyName] = nativeType(value);
        }
      } catch (e) {
        console.error(e);
      }
    },
    // remove namespace & camelCase
    elementNameFn: (attributeName) => camelCase(attributeName.replace(/^.+:/, "")),
    attributesFn: (value) => {
      const newVal = { ...value };
      delete newVal.xmlns;
      return newVal;
    },
    ignoreDeclaration: true
  });
  const responseBodies = Array.isArray(result.multistatus.response) ? result.multistatus.response : [result.multistatus.response];
  return responseBodies.map((responseBody) => {
    var _a, _b;
    const statusRegex = /^\S+\s(?<status>\d+)\s(?<statusText>.+)$/;
    if (!responseBody) {
      return {
        status: davResponse.status,
        statusText: davResponse.text,
        ok: davResponse.status >= 200 && davResponse.status < 300
      };
    }
    const matchArr = statusRegex.exec(responseBody.status);
    return {
      raw: result,
      href: responseBody.href,
      status: (matchArr == null ? void 0 : matchArr.groups) ? Number.parseInt(matchArr == null ? void 0 : matchArr.groups.status, 10) : davResponse.status,
      statusText: (_b = (_a = matchArr == null ? void 0 : matchArr.groups) == null ? void 0 : _a.statusText) != null ? _b : davResponse.text,
      ok: !responseBody.error,
      error: responseBody.error,
      responsedescription: responseBody.responsedescription,
      props: (Array.isArray(responseBody.propstat) ? responseBody.propstat : [responseBody.propstat]).reduce((prev, curr) => {
        return {
          ...prev,
          ...curr == null ? void 0 : curr.prop
        };
      }, {})
    };
  });
}
function nativeType(value) {
  const nValue = Number(value);
  if (!Number.isNaN(nValue)) {
    return nValue;
  }
  const bValue = value.toLowerCase();
  if (bValue === "true") {
    return true;
  }
  if (bValue === "false") {
    return false;
  }
  return value;
}
function camelCase(str) {
  return str.replace(/([-_]\w)/g, (g) => g[1].toUpperCase());
}
function urlContains(urlA, urlB) {
  if (!urlA && !urlB) {
    return true;
  }
  if (!urlA || !urlB) {
    return false;
  }
  const trimmedUrlA = urlA.trim();
  const trimmedUrlB = urlB.trim();
  const strippedUrlA = trimmedUrlA.slice(-1) === "/" ? trimmedUrlA.slice(0, -1) : trimmedUrlA;
  const strippedUrlB = trimmedUrlB.slice(-1) === "/" ? trimmedUrlB.slice(0, -1) : trimmedUrlB;
  return urlA.includes(strippedUrlB) || urlB.includes(strippedUrlA);
}
async function supportedReportSet(params) {
  var _a, _b, _c, _d, _e;
  const { collection, headers } = params;
  const res = await propfind({
    url: collection.url,
    props: {
      [`${DAVNamespaceShort.DAV}:supported-report-set`]: {}
    },
    depth: "0",
    headers
  });
  return (_e = (_d = (_c = (_b = (_a = res[0]) == null ? void 0 : _a.props) == null ? void 0 : _b.supportedReportSet) == null ? void 0 : _c.supportedReport) == null ? void 0 : _d.map(
    (sr) => Object.keys(sr.report)[0]
  )) != null ? _e : [];
}

// src/SettingTab.ts
var import_obsidian2 = require("obsidian");
var DEFAULT_SETTINGS = {
  username: "",
  password: "",
  folder: "Contacts",
  isNameHeading: true,
  telLabels: false,
  emailLabels: false,
  urlLabels: false,
  relatedLabels: false,
  addressLabels: false,
  iCloudServerUrl: "https://contacts.icloud.com",
  excludedKeys: "n photo prodid rev uid version xAbadr xAbLabel xAblabel xAbShowAs xImagehash xImagetype xSharedPhotoDisplayPref xAddressingGrammar xAppleSubadministrativearea xAppleSublocality vnd63SensitiveContentConfig"
};
var SettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian2.Setting(containerEl).setName("iCloud username").setDesc("The email used to login to iCloud").addText(
      (text) => text.setPlaceholder("Enter your username").setValue(this.plugin.settings.username).onChange(async (value) => {
        this.plugin.settings.username = value;
        await this.plugin.saveSettings();
      })
    );
    let passwordInputEl;
    const passwordSettingEl = new import_obsidian2.Setting(containerEl).setName("iCloud app specific password").setDesc(
      "You need to generate an app-specific password for your iCloud account."
    ).addText(
      (text) => text.setPlaceholder("App specific password").setValue(this.plugin.settings.password).onChange(async (value) => {
        this.plugin.settings.password = value;
        await this.plugin.saveSettings();
      }).then((textEl) => {
        passwordInputEl = textEl;
      }).inputEl.setAttribute("type", "password")
    );
    passwordSettingEl.addToggle(
      (v) => v.onChange((value) => {
        if (value) {
          passwordInputEl.inputEl.setAttribute("type", "clear");
        } else {
          passwordInputEl.inputEl.setAttribute("type", "password");
        }
      })
    );
    containerEl.appendChild(
      createEl("a", {
        text: "Create iCloud app specific password",
        href: "https://support.apple.com/en-us/102654",
        cls: "linkMoreInfo"
      })
    );
    new import_obsidian2.Setting(containerEl).setName("ICloud server URL").setDesc(
      "The URL of the iCloud server. Defaults to 'https://contacts.icloud.com'. Chinese users may need to change this to 'https://contacts.icloud.com.cn'"
    ).addText(
      (text) => text.setPlaceholder("Url of the iCloud server").setValue(this.plugin.settings.iCloudServerUrl).onChange(async (value) => {
        this.plugin.settings.iCloudServerUrl = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Contacts folder").setDesc("The folder where contacts will be stored").addText(
      (text) => text.setPlaceholder("Enter folder name").setValue(this.plugin.settings.folder).onChange(async (value) => {
        this.plugin.settings.folder = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("br");
    containerEl.createEl("h3", { text: "Parameters" });
    containerEl.createEl("small", {
      text: "Remember to run Update Contacts after changing any of the following to have the changes take effect."
    });
    new import_obsidian2.Setting(containerEl).setName("Add heading with contact name to the file contents").addToggle(
      (bool) => bool.setValue(!!this.plugin.settings.isNameHeading).onChange(async (value) => {
        this.plugin.settings.isNameHeading = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Add labels to telephone numbers").addToggle(
      (bool) => bool.setValue(this.plugin.settings.telLabels).onChange(async (value) => {
        this.plugin.settings.telLabels = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Add labels to emails").addToggle(
      (bool) => bool.setValue(this.plugin.settings.emailLabels).onChange(async (value) => {
        this.plugin.settings.emailLabels = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Add labels to urls").addToggle(
      (bool) => bool.setValue(this.plugin.settings.urlLabels).onChange(async (value) => {
        this.plugin.settings.urlLabels = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Add labels to related names").addToggle(
      (bool) => bool.setValue(this.plugin.settings.relatedLabels).onChange(async (value) => {
        this.plugin.settings.relatedLabels = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Add labels to addresses").addToggle(
      (bool) => bool.setValue(this.plugin.settings.addressLabels).onChange(async (value) => {
        this.plugin.settings.addressLabels = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Excluded keys").setDesc(
      "A space delimited list of all the keys that should be excluded in the properties of each contact. The data will still be pressent under the iCloudVCard propertie"
    ).addTextArea(
      (text) => text.setPlaceholder(
        "Add space delimited list of keys to exclude"
      ).setValue(this.plugin.settings.excludedKeys).onChange(async (value) => {
        this.plugin.settings.excludedKeys = value;
        await this.plugin.saveSettings();
      })
    );
  }
};

// main.ts
function showNotice(message, duration) {
  const notice = new import_obsidian3.Notice(message, duration);
  return {
    setMessage: (message2) => {
      notice.setMessage(message2);
    },
    hide: () => notice.hide()
  };
}
function createObsidianApiWrapper(app) {
  return {
    normalizePath: import_obsidian3.normalizePath,
    app: {
      fileManager: {
        processFrontMatter: (file, fn) => app.fileManager.processFrontMatter(file, fn),
        renameFile: (file, newPath) => app.fileManager.renameFile(file, newPath)
      },
      vault: {
        adapter: {
          list: (normalizedPath) => app.vault.adapter.list(normalizedPath),
          exists: (normalizedPath, sensitive) => app.vault.adapter.exists(normalizedPath, sensitive)
        },
        append: (file, data, _options) => app.vault.append(file, data),
        create: (path, data, _options) => app.vault.create(path, data),
        createFolder: (path) => app.vault.createFolder(path),
        getFileByPath: (path) => app.vault.getFileByPath(path),
        getFolderByPath: (path) => app.vault.getFolderByPath(path),
        process: (file, fn, _options) => app.vault.process(file, fn)
      },
      workspace: {
        getLeaf: () => ({
          openFile: (file, _openState) => app.workspace.getLeaf().openFile(file)
        })
      },
      metadataCache: {
        getCache: (path) => app.metadataCache.getCache(path)
      }
    }
  };
}
var ICloudContacts = class extends import_obsidian3.Plugin {
  async onload() {
    this.settings = Object.assign(
      {},
      DEFAULT_SETTINGS,
      await this.loadData()
    );
    this.api = new ICloudContactsApi(
      createObsidianApiWrapper(this.app),
      this.settings,
      fetchContacts,
      showNotice
    );
    this.addCommand({
      id: "update-contacts",
      name: "Update Contacts",
      callback: async () => {
        const { updateData, usedSettings } = await this.api.updateContacts();
        await this.saveRunData(updateData, usedSettings);
      }
    });
    this.addCommand({
      id: "update-all-contacts",
      name: "Update all Contacts",
      callback: async () => {
        const { updateData, usedSettings } = await this.api.updateContacts({
          rewriteAll: true
        });
        await this.saveRunData(updateData, usedSettings);
      }
    });
    this.addRibbonIcon(
      "sync",
      "Update Contacts",
      () => this.api.updateContacts()
    );
    this.addSettingTab(new SettingTab(this.app, this));
  }
  async saveRunData(updateData, usedSettings) {
    this.settings.previousUpdateData = updateData;
    delete usedSettings.previousUpdateData;
    delete usedSettings.previousUpdateSettings;
    this.settings.previousUpdateSettings = usedSettings;
    await this.saveSettings();
  }
  onunload() {
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
/*! Bundled license information:

sax/lib/sax.js:
  (*! http://mths.be/fromcodepoint v0.1.0 by @mathias *)
*/

/* nosourcemap */